// Code generated by ent, DO NOT EDIT.

package group

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the group type in the database.
	Label = "group"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldDeletedAt holds the string denoting the deleted_at field in the database.
	FieldDeletedAt = "deleted_at"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldDescription holds the string denoting the description field in the database.
	FieldDescription = "description"
	// FieldRateMultiplier holds the string denoting the rate_multiplier field in the database.
	FieldRateMultiplier = "rate_multiplier"
	// FieldIsExclusive holds the string denoting the is_exclusive field in the database.
	FieldIsExclusive = "is_exclusive"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldPlatform holds the string denoting the platform field in the database.
	FieldPlatform = "platform"
	// FieldSubscriptionType holds the string denoting the subscription_type field in the database.
	FieldSubscriptionType = "subscription_type"
	// FieldDailyLimitUsd holds the string denoting the daily_limit_usd field in the database.
	FieldDailyLimitUsd = "daily_limit_usd"
	// FieldWeeklyLimitUsd holds the string denoting the weekly_limit_usd field in the database.
	FieldWeeklyLimitUsd = "weekly_limit_usd"
	// FieldMonthlyLimitUsd holds the string denoting the monthly_limit_usd field in the database.
	FieldMonthlyLimitUsd = "monthly_limit_usd"
	// FieldDefaultValidityDays holds the string denoting the default_validity_days field in the database.
	FieldDefaultValidityDays = "default_validity_days"
	// EdgeAPIKeys holds the string denoting the api_keys edge name in mutations.
	EdgeAPIKeys = "api_keys"
	// EdgeRedeemCodes holds the string denoting the redeem_codes edge name in mutations.
	EdgeRedeemCodes = "redeem_codes"
	// EdgeSubscriptions holds the string denoting the subscriptions edge name in mutations.
	EdgeSubscriptions = "subscriptions"
	// EdgeUsageLogs holds the string denoting the usage_logs edge name in mutations.
	EdgeUsageLogs = "usage_logs"
	// EdgeAccounts holds the string denoting the accounts edge name in mutations.
	EdgeAccounts = "accounts"
	// EdgeAllowedUsers holds the string denoting the allowed_users edge name in mutations.
	EdgeAllowedUsers = "allowed_users"
	// EdgeAccountGroups holds the string denoting the account_groups edge name in mutations.
	EdgeAccountGroups = "account_groups"
	// EdgeUserAllowedGroups holds the string denoting the user_allowed_groups edge name in mutations.
	EdgeUserAllowedGroups = "user_allowed_groups"
	// Table holds the table name of the group in the database.
	Table = "groups"
	// APIKeysTable is the table that holds the api_keys relation/edge.
	APIKeysTable = "api_keys"
	// APIKeysInverseTable is the table name for the APIKey entity.
	// It exists in this package in order to avoid circular dependency with the "apikey" package.
	APIKeysInverseTable = "api_keys"
	// APIKeysColumn is the table column denoting the api_keys relation/edge.
	APIKeysColumn = "group_id"
	// RedeemCodesTable is the table that holds the redeem_codes relation/edge.
	RedeemCodesTable = "redeem_codes"
	// RedeemCodesInverseTable is the table name for the RedeemCode entity.
	// It exists in this package in order to avoid circular dependency with the "redeemcode" package.
	RedeemCodesInverseTable = "redeem_codes"
	// RedeemCodesColumn is the table column denoting the redeem_codes relation/edge.
	RedeemCodesColumn = "group_id"
	// SubscriptionsTable is the table that holds the subscriptions relation/edge.
	SubscriptionsTable = "user_subscriptions"
	// SubscriptionsInverseTable is the table name for the UserSubscription entity.
	// It exists in this package in order to avoid circular dependency with the "usersubscription" package.
	SubscriptionsInverseTable = "user_subscriptions"
	// SubscriptionsColumn is the table column denoting the subscriptions relation/edge.
	SubscriptionsColumn = "group_id"
	// UsageLogsTable is the table that holds the usage_logs relation/edge.
	UsageLogsTable = "usage_logs"
	// UsageLogsInverseTable is the table name for the UsageLog entity.
	// It exists in this package in order to avoid circular dependency with the "usagelog" package.
	UsageLogsInverseTable = "usage_logs"
	// UsageLogsColumn is the table column denoting the usage_logs relation/edge.
	UsageLogsColumn = "group_id"
	// AccountsTable is the table that holds the accounts relation/edge. The primary key declared below.
	AccountsTable = "account_groups"
	// AccountsInverseTable is the table name for the Account entity.
	// It exists in this package in order to avoid circular dependency with the "account" package.
	AccountsInverseTable = "accounts"
	// AllowedUsersTable is the table that holds the allowed_users relation/edge. The primary key declared below.
	AllowedUsersTable = "user_allowed_groups"
	// AllowedUsersInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	AllowedUsersInverseTable = "users"
	// AccountGroupsTable is the table that holds the account_groups relation/edge.
	AccountGroupsTable = "account_groups"
	// AccountGroupsInverseTable is the table name for the AccountGroup entity.
	// It exists in this package in order to avoid circular dependency with the "accountgroup" package.
	AccountGroupsInverseTable = "account_groups"
	// AccountGroupsColumn is the table column denoting the account_groups relation/edge.
	AccountGroupsColumn = "group_id"
	// UserAllowedGroupsTable is the table that holds the user_allowed_groups relation/edge.
	UserAllowedGroupsTable = "user_allowed_groups"
	// UserAllowedGroupsInverseTable is the table name for the UserAllowedGroup entity.
	// It exists in this package in order to avoid circular dependency with the "userallowedgroup" package.
	UserAllowedGroupsInverseTable = "user_allowed_groups"
	// UserAllowedGroupsColumn is the table column denoting the user_allowed_groups relation/edge.
	UserAllowedGroupsColumn = "group_id"
)

// Columns holds all SQL columns for group fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldDeletedAt,
	FieldName,
	FieldDescription,
	FieldRateMultiplier,
	FieldIsExclusive,
	FieldStatus,
	FieldPlatform,
	FieldSubscriptionType,
	FieldDailyLimitUsd,
	FieldWeeklyLimitUsd,
	FieldMonthlyLimitUsd,
	FieldDefaultValidityDays,
}

var (
	// AccountsPrimaryKey and AccountsColumn2 are the table columns denoting the
	// primary key for the accounts relation (M2M).
	AccountsPrimaryKey = []string{"account_id", "group_id"}
	// AllowedUsersPrimaryKey and AllowedUsersColumn2 are the table columns denoting the
	// primary key for the allowed_users relation (M2M).
	AllowedUsersPrimaryKey = []string{"user_id", "group_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// Note that the variables below are initialized by the runtime
// package on the initialization of the application. Therefore,
// it should be imported in the main as follows:
//
//	import _ "github.com/Wei-Shaw/sub2api/ent/runtime"
var (
	Hooks        [1]ent.Hook
	Interceptors [1]ent.Interceptor
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
	UpdateDefaultUpdatedAt func() time.Time
	// NameValidator is a validator for the "name" field. It is called by the builders before save.
	NameValidator func(string) error
	// DefaultRateMultiplier holds the default value on creation for the "rate_multiplier" field.
	DefaultRateMultiplier float64
	// DefaultIsExclusive holds the default value on creation for the "is_exclusive" field.
	DefaultIsExclusive bool
	// DefaultStatus holds the default value on creation for the "status" field.
	DefaultStatus string
	// StatusValidator is a validator for the "status" field. It is called by the builders before save.
	StatusValidator func(string) error
	// DefaultPlatform holds the default value on creation for the "platform" field.
	DefaultPlatform string
	// PlatformValidator is a validator for the "platform" field. It is called by the builders before save.
	PlatformValidator func(string) error
	// DefaultSubscriptionType holds the default value on creation for the "subscription_type" field.
	DefaultSubscriptionType string
	// SubscriptionTypeValidator is a validator for the "subscription_type" field. It is called by the builders before save.
	SubscriptionTypeValidator func(string) error
	// DefaultDefaultValidityDays holds the default value on creation for the "default_validity_days" field.
	DefaultDefaultValidityDays int
)

// OrderOption defines the ordering options for the Group queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByDeletedAt orders the results by the deleted_at field.
func ByDeletedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDeletedAt, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByDescription orders the results by the description field.
func ByDescription(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDescription, opts...).ToFunc()
}

// ByRateMultiplier orders the results by the rate_multiplier field.
func ByRateMultiplier(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldRateMultiplier, opts...).ToFunc()
}

// ByIsExclusive orders the results by the is_exclusive field.
func ByIsExclusive(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsExclusive, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByPlatform orders the results by the platform field.
func ByPlatform(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPlatform, opts...).ToFunc()
}

// BySubscriptionType orders the results by the subscription_type field.
func BySubscriptionType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubscriptionType, opts...).ToFunc()
}

// ByDailyLimitUsd orders the results by the daily_limit_usd field.
func ByDailyLimitUsd(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDailyLimitUsd, opts...).ToFunc()
}

// ByWeeklyLimitUsd orders the results by the weekly_limit_usd field.
func ByWeeklyLimitUsd(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldWeeklyLimitUsd, opts...).ToFunc()
}

// ByMonthlyLimitUsd orders the results by the monthly_limit_usd field.
func ByMonthlyLimitUsd(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMonthlyLimitUsd, opts...).ToFunc()
}

// ByDefaultValidityDays orders the results by the default_validity_days field.
func ByDefaultValidityDays(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDefaultValidityDays, opts...).ToFunc()
}

// ByAPIKeysCount orders the results by api_keys count.
func ByAPIKeysCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAPIKeysStep(), opts...)
	}
}

// ByAPIKeys orders the results by api_keys terms.
func ByAPIKeys(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAPIKeysStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByRedeemCodesCount orders the results by redeem_codes count.
func ByRedeemCodesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newRedeemCodesStep(), opts...)
	}
}

// ByRedeemCodes orders the results by redeem_codes terms.
func ByRedeemCodes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newRedeemCodesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// BySubscriptionsCount orders the results by subscriptions count.
func BySubscriptionsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newSubscriptionsStep(), opts...)
	}
}

// BySubscriptions orders the results by subscriptions terms.
func BySubscriptions(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSubscriptionsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByUsageLogsCount orders the results by usage_logs count.
func ByUsageLogsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newUsageLogsStep(), opts...)
	}
}

// ByUsageLogs orders the results by usage_logs terms.
func ByUsageLogs(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUsageLogsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAccountsCount orders the results by accounts count.
func ByAccountsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAccountsStep(), opts...)
	}
}

// ByAccounts orders the results by accounts terms.
func ByAccounts(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAccountsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAllowedUsersCount orders the results by allowed_users count.
func ByAllowedUsersCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAllowedUsersStep(), opts...)
	}
}

// ByAllowedUsers orders the results by allowed_users terms.
func ByAllowedUsers(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAllowedUsersStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAccountGroupsCount orders the results by account_groups count.
func ByAccountGroupsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAccountGroupsStep(), opts...)
	}
}

// ByAccountGroups orders the results by account_groups terms.
func ByAccountGroups(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAccountGroupsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByUserAllowedGroupsCount orders the results by user_allowed_groups count.
func ByUserAllowedGroupsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newUserAllowedGroupsStep(), opts...)
	}
}

// ByUserAllowedGroups orders the results by user_allowed_groups terms.
func ByUserAllowedGroups(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUserAllowedGroupsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newAPIKeysStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(APIKeysInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, APIKeysTable, APIKeysColumn),
	)
}
func newRedeemCodesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(RedeemCodesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, RedeemCodesTable, RedeemCodesColumn),
	)
}
func newSubscriptionsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SubscriptionsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, SubscriptionsTable, SubscriptionsColumn),
	)
}
func newUsageLogsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UsageLogsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, UsageLogsTable, UsageLogsColumn),
	)
}
func newAccountsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AccountsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, AccountsTable, AccountsPrimaryKey...),
	)
}
func newAllowedUsersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AllowedUsersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, AllowedUsersTable, AllowedUsersPrimaryKey...),
	)
}
func newAccountGroupsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AccountGroupsInverseTable, AccountGroupsColumn),
		sqlgraph.Edge(sqlgraph.O2M, true, AccountGroupsTable, AccountGroupsColumn),
	)
}
func newUserAllowedGroupsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UserAllowedGroupsInverseTable, UserAllowedGroupsColumn),
		sqlgraph.Edge(sqlgraph.O2M, true, UserAllowedGroupsTable, UserAllowedGroupsColumn),
	)
}
