// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Wei-Shaw/sub2api/ent/account"
	"github.com/Wei-Shaw/sub2api/ent/accountgroup"
	"github.com/Wei-Shaw/sub2api/ent/apikey"
	"github.com/Wei-Shaw/sub2api/ent/group"
	"github.com/Wei-Shaw/sub2api/ent/predicate"
	"github.com/Wei-Shaw/sub2api/ent/proxy"
	"github.com/Wei-Shaw/sub2api/ent/redeemcode"
	"github.com/Wei-Shaw/sub2api/ent/setting"
	"github.com/Wei-Shaw/sub2api/ent/usagelog"
	"github.com/Wei-Shaw/sub2api/ent/user"
	"github.com/Wei-Shaw/sub2api/ent/userallowedgroup"
	"github.com/Wei-Shaw/sub2api/ent/userattributedefinition"
	"github.com/Wei-Shaw/sub2api/ent/userattributevalue"
	"github.com/Wei-Shaw/sub2api/ent/usersubscription"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey                  = "APIKey"
	TypeAccount                 = "Account"
	TypeAccountGroup            = "AccountGroup"
	TypeGroup                   = "Group"
	TypeProxy                   = "Proxy"
	TypeRedeemCode              = "RedeemCode"
	TypeSetting                 = "Setting"
	TypeUsageLog                = "UsageLog"
	TypeUser                    = "User"
	TypeUserAllowedGroup        = "UserAllowedGroup"
	TypeUserAttributeDefinition = "UserAttributeDefinition"
	TypeUserAttributeValue      = "UserAttributeValue"
	TypeUserSubscription        = "UserSubscription"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	key               *string
	name              *string
	status            *string
	clearedFields     map[string]struct{}
	user              *int64
	cleareduser       bool
	group             *int64
	clearedgroup      bool
	usage_logs        map[int64]struct{}
	removedusage_logs map[int64]struct{}
	clearedusage_logs bool
	done              bool
	oldValue          func(context.Context) (*APIKey, error)
	predicates        []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id int64) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *APIKeyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *APIKeyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *APIKeyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[apikey.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *APIKeyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *APIKeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, apikey.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetKey sets the "key" field.
func (m *APIKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *APIKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *APIKeyMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetGroupID sets the "group_id" field.
func (m *APIKeyMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *APIKeyMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldGroupID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *APIKeyMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[apikey.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *APIKeyMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[apikey.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *APIKeyMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, apikey.FieldGroupID)
}

// SetStatus sets the "status" field.
func (m *APIKeyMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *APIKeyMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *APIKeyMutation) ResetStatus() {
	m.status = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *APIKeyMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[apikey.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *APIKeyMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *APIKeyMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *APIKeyMutation) AddUsageLogIDs(ids ...int64) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *APIKeyMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *APIKeyMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *APIKeyMutation) RemoveUsageLogIDs(ids ...int64) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *APIKeyMutation) RemovedUsageLogsIDs() (ids []int64) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *APIKeyMutation) UsageLogsIDs() (ids []int64) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *APIKeyMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.key != nil {
		fields = append(fields, apikey.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.group != nil {
		fields = append(fields, apikey.FieldGroupID)
	}
	if m.status != nil {
		fields = append(fields, apikey.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldDeletedAt:
		return m.DeletedAt()
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldKey:
		return m.Key()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldGroupID:
		return m.GroupID()
	case apikey.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldKey:
		return m.OldKey(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldGroupID:
		return m.OldGroupID(ctx)
	case apikey.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apikey.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case apikey.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldDeletedAt) {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.FieldCleared(apikey.FieldGroupID) {
		fields = append(fields, apikey.FieldGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case apikey.FieldGroupID:
		m.ClearGroupID()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldKey:
		m.ResetKey()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldGroupID:
		m.ResetGroupID()
		return nil
	case apikey.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, apikey.EdgeGroup)
	}
	if m.usage_logs != nil {
		edges = append(edges, apikey.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusage_logs != nil {
		edges = append(edges, apikey.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, apikey.EdgeGroup)
	}
	if m.clearedusage_logs {
		edges = append(edges, apikey.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	case apikey.EdgeGroup:
		return m.clearedgroup
	case apikey.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	case apikey.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	case apikey.EdgeGroup:
		m.ResetGroup()
		return nil
	case apikey.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	name                  *string
	platform              *string
	_type                 *string
	credentials           *map[string]interface{}
	extra                 *map[string]interface{}
	concurrency           *int
	addconcurrency        *int
	priority              *int
	addpriority           *int
	status                *string
	error_message         *string
	last_used_at          *time.Time
	schedulable           *bool
	rate_limited_at       *time.Time
	rate_limit_reset_at   *time.Time
	overload_until        *time.Time
	session_window_start  *time.Time
	session_window_end    *time.Time
	session_window_status *string
	clearedFields         map[string]struct{}
	groups                map[int64]struct{}
	removedgroups         map[int64]struct{}
	clearedgroups         bool
	proxy                 *int64
	clearedproxy          bool
	usage_logs            map[int64]struct{}
	removedusage_logs     map[int64]struct{}
	clearedusage_logs     bool
	done                  bool
	oldValue              func(context.Context) (*Account, error)
	predicates            []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int64) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[account.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, account.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetPlatform sets the "platform" field.
func (m *AccountMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AccountMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AccountMutation) ResetPlatform() {
	m.platform = nil
}

// SetType sets the "type" field.
func (m *AccountMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AccountMutation) ResetType() {
	m._type = nil
}

// SetCredentials sets the "credentials" field.
func (m *AccountMutation) SetCredentials(value map[string]interface{}) {
	m.credentials = &value
}

// Credentials returns the value of the "credentials" field in the mutation.
func (m *AccountMutation) Credentials() (r map[string]interface{}, exists bool) {
	v := m.credentials
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentials returns the old "credentials" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCredentials(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentials is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentials requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentials: %w", err)
	}
	return oldValue.Credentials, nil
}

// ResetCredentials resets all changes to the "credentials" field.
func (m *AccountMutation) ResetCredentials() {
	m.credentials = nil
}

// SetExtra sets the "extra" field.
func (m *AccountMutation) SetExtra(value map[string]interface{}) {
	m.extra = &value
}

// Extra returns the value of the "extra" field in the mutation.
func (m *AccountMutation) Extra() (r map[string]interface{}, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldExtra(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ResetExtra resets all changes to the "extra" field.
func (m *AccountMutation) ResetExtra() {
	m.extra = nil
}

// SetProxyID sets the "proxy_id" field.
func (m *AccountMutation) SetProxyID(i int64) {
	m.proxy = &i
}

// ProxyID returns the value of the "proxy_id" field in the mutation.
func (m *AccountMutation) ProxyID() (r int64, exists bool) {
	v := m.proxy
	if v == nil {
		return
	}
	return *v, true
}

// OldProxyID returns the old "proxy_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldProxyID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProxyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProxyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProxyID: %w", err)
	}
	return oldValue.ProxyID, nil
}

// ClearProxyID clears the value of the "proxy_id" field.
func (m *AccountMutation) ClearProxyID() {
	m.proxy = nil
	m.clearedFields[account.FieldProxyID] = struct{}{}
}

// ProxyIDCleared returns if the "proxy_id" field was cleared in this mutation.
func (m *AccountMutation) ProxyIDCleared() bool {
	_, ok := m.clearedFields[account.FieldProxyID]
	return ok
}

// ResetProxyID resets all changes to the "proxy_id" field.
func (m *AccountMutation) ResetProxyID() {
	m.proxy = nil
	delete(m.clearedFields, account.FieldProxyID)
}

// SetConcurrency sets the "concurrency" field.
func (m *AccountMutation) SetConcurrency(i int) {
	m.concurrency = &i
	m.addconcurrency = nil
}

// Concurrency returns the value of the "concurrency" field in the mutation.
func (m *AccountMutation) Concurrency() (r int, exists bool) {
	v := m.concurrency
	if v == nil {
		return
	}
	return *v, true
}

// OldConcurrency returns the old "concurrency" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldConcurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcurrency: %w", err)
	}
	return oldValue.Concurrency, nil
}

// AddConcurrency adds i to the "concurrency" field.
func (m *AccountMutation) AddConcurrency(i int) {
	if m.addconcurrency != nil {
		*m.addconcurrency += i
	} else {
		m.addconcurrency = &i
	}
}

// AddedConcurrency returns the value that was added to the "concurrency" field in this mutation.
func (m *AccountMutation) AddedConcurrency() (r int, exists bool) {
	v := m.addconcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ResetConcurrency resets all changes to the "concurrency" field.
func (m *AccountMutation) ResetConcurrency() {
	m.concurrency = nil
	m.addconcurrency = nil
}

// SetPriority sets the "priority" field.
func (m *AccountMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *AccountMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *AccountMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *AccountMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *AccountMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetStatus sets the "status" field.
func (m *AccountMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AccountMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AccountMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *AccountMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AccountMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AccountMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[account.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AccountMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[account.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AccountMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, account.FieldErrorMessage)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *AccountMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *AccountMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *AccountMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[account.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *AccountMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *AccountMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, account.FieldLastUsedAt)
}

// SetSchedulable sets the "schedulable" field.
func (m *AccountMutation) SetSchedulable(b bool) {
	m.schedulable = &b
}

// Schedulable returns the value of the "schedulable" field in the mutation.
func (m *AccountMutation) Schedulable() (r bool, exists bool) {
	v := m.schedulable
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedulable returns the old "schedulable" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSchedulable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchedulable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchedulable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedulable: %w", err)
	}
	return oldValue.Schedulable, nil
}

// ResetSchedulable resets all changes to the "schedulable" field.
func (m *AccountMutation) ResetSchedulable() {
	m.schedulable = nil
}

// SetRateLimitedAt sets the "rate_limited_at" field.
func (m *AccountMutation) SetRateLimitedAt(t time.Time) {
	m.rate_limited_at = &t
}

// RateLimitedAt returns the value of the "rate_limited_at" field in the mutation.
func (m *AccountMutation) RateLimitedAt() (r time.Time, exists bool) {
	v := m.rate_limited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRateLimitedAt returns the old "rate_limited_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRateLimitedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateLimitedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateLimitedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateLimitedAt: %w", err)
	}
	return oldValue.RateLimitedAt, nil
}

// ClearRateLimitedAt clears the value of the "rate_limited_at" field.
func (m *AccountMutation) ClearRateLimitedAt() {
	m.rate_limited_at = nil
	m.clearedFields[account.FieldRateLimitedAt] = struct{}{}
}

// RateLimitedAtCleared returns if the "rate_limited_at" field was cleared in this mutation.
func (m *AccountMutation) RateLimitedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldRateLimitedAt]
	return ok
}

// ResetRateLimitedAt resets all changes to the "rate_limited_at" field.
func (m *AccountMutation) ResetRateLimitedAt() {
	m.rate_limited_at = nil
	delete(m.clearedFields, account.FieldRateLimitedAt)
}

// SetRateLimitResetAt sets the "rate_limit_reset_at" field.
func (m *AccountMutation) SetRateLimitResetAt(t time.Time) {
	m.rate_limit_reset_at = &t
}

// RateLimitResetAt returns the value of the "rate_limit_reset_at" field in the mutation.
func (m *AccountMutation) RateLimitResetAt() (r time.Time, exists bool) {
	v := m.rate_limit_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRateLimitResetAt returns the old "rate_limit_reset_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRateLimitResetAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateLimitResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateLimitResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateLimitResetAt: %w", err)
	}
	return oldValue.RateLimitResetAt, nil
}

// ClearRateLimitResetAt clears the value of the "rate_limit_reset_at" field.
func (m *AccountMutation) ClearRateLimitResetAt() {
	m.rate_limit_reset_at = nil
	m.clearedFields[account.FieldRateLimitResetAt] = struct{}{}
}

// RateLimitResetAtCleared returns if the "rate_limit_reset_at" field was cleared in this mutation.
func (m *AccountMutation) RateLimitResetAtCleared() bool {
	_, ok := m.clearedFields[account.FieldRateLimitResetAt]
	return ok
}

// ResetRateLimitResetAt resets all changes to the "rate_limit_reset_at" field.
func (m *AccountMutation) ResetRateLimitResetAt() {
	m.rate_limit_reset_at = nil
	delete(m.clearedFields, account.FieldRateLimitResetAt)
}

// SetOverloadUntil sets the "overload_until" field.
func (m *AccountMutation) SetOverloadUntil(t time.Time) {
	m.overload_until = &t
}

// OverloadUntil returns the value of the "overload_until" field in the mutation.
func (m *AccountMutation) OverloadUntil() (r time.Time, exists bool) {
	v := m.overload_until
	if v == nil {
		return
	}
	return *v, true
}

// OldOverloadUntil returns the old "overload_until" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOverloadUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverloadUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverloadUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverloadUntil: %w", err)
	}
	return oldValue.OverloadUntil, nil
}

// ClearOverloadUntil clears the value of the "overload_until" field.
func (m *AccountMutation) ClearOverloadUntil() {
	m.overload_until = nil
	m.clearedFields[account.FieldOverloadUntil] = struct{}{}
}

// OverloadUntilCleared returns if the "overload_until" field was cleared in this mutation.
func (m *AccountMutation) OverloadUntilCleared() bool {
	_, ok := m.clearedFields[account.FieldOverloadUntil]
	return ok
}

// ResetOverloadUntil resets all changes to the "overload_until" field.
func (m *AccountMutation) ResetOverloadUntil() {
	m.overload_until = nil
	delete(m.clearedFields, account.FieldOverloadUntil)
}

// SetSessionWindowStart sets the "session_window_start" field.
func (m *AccountMutation) SetSessionWindowStart(t time.Time) {
	m.session_window_start = &t
}

// SessionWindowStart returns the value of the "session_window_start" field in the mutation.
func (m *AccountMutation) SessionWindowStart() (r time.Time, exists bool) {
	v := m.session_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionWindowStart returns the old "session_window_start" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSessionWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionWindowStart: %w", err)
	}
	return oldValue.SessionWindowStart, nil
}

// ClearSessionWindowStart clears the value of the "session_window_start" field.
func (m *AccountMutation) ClearSessionWindowStart() {
	m.session_window_start = nil
	m.clearedFields[account.FieldSessionWindowStart] = struct{}{}
}

// SessionWindowStartCleared returns if the "session_window_start" field was cleared in this mutation.
func (m *AccountMutation) SessionWindowStartCleared() bool {
	_, ok := m.clearedFields[account.FieldSessionWindowStart]
	return ok
}

// ResetSessionWindowStart resets all changes to the "session_window_start" field.
func (m *AccountMutation) ResetSessionWindowStart() {
	m.session_window_start = nil
	delete(m.clearedFields, account.FieldSessionWindowStart)
}

// SetSessionWindowEnd sets the "session_window_end" field.
func (m *AccountMutation) SetSessionWindowEnd(t time.Time) {
	m.session_window_end = &t
}

// SessionWindowEnd returns the value of the "session_window_end" field in the mutation.
func (m *AccountMutation) SessionWindowEnd() (r time.Time, exists bool) {
	v := m.session_window_end
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionWindowEnd returns the old "session_window_end" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSessionWindowEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionWindowEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionWindowEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionWindowEnd: %w", err)
	}
	return oldValue.SessionWindowEnd, nil
}

// ClearSessionWindowEnd clears the value of the "session_window_end" field.
func (m *AccountMutation) ClearSessionWindowEnd() {
	m.session_window_end = nil
	m.clearedFields[account.FieldSessionWindowEnd] = struct{}{}
}

// SessionWindowEndCleared returns if the "session_window_end" field was cleared in this mutation.
func (m *AccountMutation) SessionWindowEndCleared() bool {
	_, ok := m.clearedFields[account.FieldSessionWindowEnd]
	return ok
}

// ResetSessionWindowEnd resets all changes to the "session_window_end" field.
func (m *AccountMutation) ResetSessionWindowEnd() {
	m.session_window_end = nil
	delete(m.clearedFields, account.FieldSessionWindowEnd)
}

// SetSessionWindowStatus sets the "session_window_status" field.
func (m *AccountMutation) SetSessionWindowStatus(s string) {
	m.session_window_status = &s
}

// SessionWindowStatus returns the value of the "session_window_status" field in the mutation.
func (m *AccountMutation) SessionWindowStatus() (r string, exists bool) {
	v := m.session_window_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionWindowStatus returns the old "session_window_status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSessionWindowStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionWindowStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionWindowStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionWindowStatus: %w", err)
	}
	return oldValue.SessionWindowStatus, nil
}

// ClearSessionWindowStatus clears the value of the "session_window_status" field.
func (m *AccountMutation) ClearSessionWindowStatus() {
	m.session_window_status = nil
	m.clearedFields[account.FieldSessionWindowStatus] = struct{}{}
}

// SessionWindowStatusCleared returns if the "session_window_status" field was cleared in this mutation.
func (m *AccountMutation) SessionWindowStatusCleared() bool {
	_, ok := m.clearedFields[account.FieldSessionWindowStatus]
	return ok
}

// ResetSessionWindowStatus resets all changes to the "session_window_status" field.
func (m *AccountMutation) ResetSessionWindowStatus() {
	m.session_window_status = nil
	delete(m.clearedFields, account.FieldSessionWindowStatus)
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *AccountMutation) AddGroupIDs(ids ...int64) {
	if m.groups == nil {
		m.groups = make(map[int64]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *AccountMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *AccountMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *AccountMutation) RemoveGroupIDs(ids ...int64) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *AccountMutation) RemovedGroupsIDs() (ids []int64) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *AccountMutation) GroupsIDs() (ids []int64) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *AccountMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// ClearProxy clears the "proxy" edge to the Proxy entity.
func (m *AccountMutation) ClearProxy() {
	m.clearedproxy = true
	m.clearedFields[account.FieldProxyID] = struct{}{}
}

// ProxyCleared reports if the "proxy" edge to the Proxy entity was cleared.
func (m *AccountMutation) ProxyCleared() bool {
	return m.ProxyIDCleared() || m.clearedproxy
}

// ProxyIDs returns the "proxy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProxyID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) ProxyIDs() (ids []int64) {
	if id := m.proxy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProxy resets all changes to the "proxy" edge.
func (m *AccountMutation) ResetProxy() {
	m.proxy = nil
	m.clearedproxy = false
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *AccountMutation) AddUsageLogIDs(ids ...int64) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *AccountMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *AccountMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *AccountMutation) RemoveUsageLogIDs(ids ...int64) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *AccountMutation) RemovedUsageLogsIDs() (ids []int64) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *AccountMutation) UsageLogsIDs() (ids []int64) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *AccountMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.platform != nil {
		fields = append(fields, account.FieldPlatform)
	}
	if m._type != nil {
		fields = append(fields, account.FieldType)
	}
	if m.credentials != nil {
		fields = append(fields, account.FieldCredentials)
	}
	if m.extra != nil {
		fields = append(fields, account.FieldExtra)
	}
	if m.proxy != nil {
		fields = append(fields, account.FieldProxyID)
	}
	if m.concurrency != nil {
		fields = append(fields, account.FieldConcurrency)
	}
	if m.priority != nil {
		fields = append(fields, account.FieldPriority)
	}
	if m.status != nil {
		fields = append(fields, account.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, account.FieldErrorMessage)
	}
	if m.last_used_at != nil {
		fields = append(fields, account.FieldLastUsedAt)
	}
	if m.schedulable != nil {
		fields = append(fields, account.FieldSchedulable)
	}
	if m.rate_limited_at != nil {
		fields = append(fields, account.FieldRateLimitedAt)
	}
	if m.rate_limit_reset_at != nil {
		fields = append(fields, account.FieldRateLimitResetAt)
	}
	if m.overload_until != nil {
		fields = append(fields, account.FieldOverloadUntil)
	}
	if m.session_window_start != nil {
		fields = append(fields, account.FieldSessionWindowStart)
	}
	if m.session_window_end != nil {
		fields = append(fields, account.FieldSessionWindowEnd)
	}
	if m.session_window_status != nil {
		fields = append(fields, account.FieldSessionWindowStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldName:
		return m.Name()
	case account.FieldPlatform:
		return m.Platform()
	case account.FieldType:
		return m.GetType()
	case account.FieldCredentials:
		return m.Credentials()
	case account.FieldExtra:
		return m.Extra()
	case account.FieldProxyID:
		return m.ProxyID()
	case account.FieldConcurrency:
		return m.Concurrency()
	case account.FieldPriority:
		return m.Priority()
	case account.FieldStatus:
		return m.Status()
	case account.FieldErrorMessage:
		return m.ErrorMessage()
	case account.FieldLastUsedAt:
		return m.LastUsedAt()
	case account.FieldSchedulable:
		return m.Schedulable()
	case account.FieldRateLimitedAt:
		return m.RateLimitedAt()
	case account.FieldRateLimitResetAt:
		return m.RateLimitResetAt()
	case account.FieldOverloadUntil:
		return m.OverloadUntil()
	case account.FieldSessionWindowStart:
		return m.SessionWindowStart()
	case account.FieldSessionWindowEnd:
		return m.SessionWindowEnd()
	case account.FieldSessionWindowStatus:
		return m.SessionWindowStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldPlatform:
		return m.OldPlatform(ctx)
	case account.FieldType:
		return m.OldType(ctx)
	case account.FieldCredentials:
		return m.OldCredentials(ctx)
	case account.FieldExtra:
		return m.OldExtra(ctx)
	case account.FieldProxyID:
		return m.OldProxyID(ctx)
	case account.FieldConcurrency:
		return m.OldConcurrency(ctx)
	case account.FieldPriority:
		return m.OldPriority(ctx)
	case account.FieldStatus:
		return m.OldStatus(ctx)
	case account.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case account.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case account.FieldSchedulable:
		return m.OldSchedulable(ctx)
	case account.FieldRateLimitedAt:
		return m.OldRateLimitedAt(ctx)
	case account.FieldRateLimitResetAt:
		return m.OldRateLimitResetAt(ctx)
	case account.FieldOverloadUntil:
		return m.OldOverloadUntil(ctx)
	case account.FieldSessionWindowStart:
		return m.OldSessionWindowStart(ctx)
	case account.FieldSessionWindowEnd:
		return m.OldSessionWindowEnd(ctx)
	case account.FieldSessionWindowStatus:
		return m.OldSessionWindowStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case account.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case account.FieldCredentials:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentials(v)
		return nil
	case account.FieldExtra:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	case account.FieldProxyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProxyID(v)
		return nil
	case account.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcurrency(v)
		return nil
	case account.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case account.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case account.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case account.FieldSchedulable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedulable(v)
		return nil
	case account.FieldRateLimitedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateLimitedAt(v)
		return nil
	case account.FieldRateLimitResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateLimitResetAt(v)
		return nil
	case account.FieldOverloadUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverloadUntil(v)
		return nil
	case account.FieldSessionWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionWindowStart(v)
		return nil
	case account.FieldSessionWindowEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionWindowEnd(v)
		return nil
	case account.FieldSessionWindowStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionWindowStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addconcurrency != nil {
		fields = append(fields, account.FieldConcurrency)
	}
	if m.addpriority != nil {
		fields = append(fields, account.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldConcurrency:
		return m.AddedConcurrency()
	case account.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConcurrency(v)
		return nil
	case account.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldDeletedAt) {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.FieldCleared(account.FieldProxyID) {
		fields = append(fields, account.FieldProxyID)
	}
	if m.FieldCleared(account.FieldErrorMessage) {
		fields = append(fields, account.FieldErrorMessage)
	}
	if m.FieldCleared(account.FieldLastUsedAt) {
		fields = append(fields, account.FieldLastUsedAt)
	}
	if m.FieldCleared(account.FieldRateLimitedAt) {
		fields = append(fields, account.FieldRateLimitedAt)
	}
	if m.FieldCleared(account.FieldRateLimitResetAt) {
		fields = append(fields, account.FieldRateLimitResetAt)
	}
	if m.FieldCleared(account.FieldOverloadUntil) {
		fields = append(fields, account.FieldOverloadUntil)
	}
	if m.FieldCleared(account.FieldSessionWindowStart) {
		fields = append(fields, account.FieldSessionWindowStart)
	}
	if m.FieldCleared(account.FieldSessionWindowEnd) {
		fields = append(fields, account.FieldSessionWindowEnd)
	}
	if m.FieldCleared(account.FieldSessionWindowStatus) {
		fields = append(fields, account.FieldSessionWindowStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case account.FieldProxyID:
		m.ClearProxyID()
		return nil
	case account.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case account.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case account.FieldRateLimitedAt:
		m.ClearRateLimitedAt()
		return nil
	case account.FieldRateLimitResetAt:
		m.ClearRateLimitResetAt()
		return nil
	case account.FieldOverloadUntil:
		m.ClearOverloadUntil()
		return nil
	case account.FieldSessionWindowStart:
		m.ClearSessionWindowStart()
		return nil
	case account.FieldSessionWindowEnd:
		m.ClearSessionWindowEnd()
		return nil
	case account.FieldSessionWindowStatus:
		m.ClearSessionWindowStatus()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldPlatform:
		m.ResetPlatform()
		return nil
	case account.FieldType:
		m.ResetType()
		return nil
	case account.FieldCredentials:
		m.ResetCredentials()
		return nil
	case account.FieldExtra:
		m.ResetExtra()
		return nil
	case account.FieldProxyID:
		m.ResetProxyID()
		return nil
	case account.FieldConcurrency:
		m.ResetConcurrency()
		return nil
	case account.FieldPriority:
		m.ResetPriority()
		return nil
	case account.FieldStatus:
		m.ResetStatus()
		return nil
	case account.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case account.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case account.FieldSchedulable:
		m.ResetSchedulable()
		return nil
	case account.FieldRateLimitedAt:
		m.ResetRateLimitedAt()
		return nil
	case account.FieldRateLimitResetAt:
		m.ResetRateLimitResetAt()
		return nil
	case account.FieldOverloadUntil:
		m.ResetOverloadUntil()
		return nil
	case account.FieldSessionWindowStart:
		m.ResetSessionWindowStart()
		return nil
	case account.FieldSessionWindowEnd:
		m.ResetSessionWindowEnd()
		return nil
	case account.FieldSessionWindowStatus:
		m.ResetSessionWindowStatus()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.groups != nil {
		edges = append(edges, account.EdgeGroups)
	}
	if m.proxy != nil {
		edges = append(edges, account.EdgeProxy)
	}
	if m.usage_logs != nil {
		edges = append(edges, account.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeProxy:
		if id := m.proxy; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgroups != nil {
		edges = append(edges, account.EdgeGroups)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, account.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgroups {
		edges = append(edges, account.EdgeGroups)
	}
	if m.clearedproxy {
		edges = append(edges, account.EdgeProxy)
	}
	if m.clearedusage_logs {
		edges = append(edges, account.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeGroups:
		return m.clearedgroups
	case account.EdgeProxy:
		return m.clearedproxy
	case account.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeProxy:
		m.ClearProxy()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeGroups:
		m.ResetGroups()
		return nil
	case account.EdgeProxy:
		m.ResetProxy()
		return nil
	case account.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AccountGroupMutation represents an operation that mutates the AccountGroup nodes in the graph.
type AccountGroupMutation struct {
	config
	op             Op
	typ            string
	priority       *int
	addpriority    *int
	created_at     *time.Time
	clearedFields  map[string]struct{}
	account        *int64
	clearedaccount bool
	group          *int64
	clearedgroup   bool
	done           bool
	oldValue       func(context.Context) (*AccountGroup, error)
	predicates     []predicate.AccountGroup
}

var _ ent.Mutation = (*AccountGroupMutation)(nil)

// accountgroupOption allows management of the mutation configuration using functional options.
type accountgroupOption func(*AccountGroupMutation)

// newAccountGroupMutation creates new mutation for the AccountGroup entity.
func newAccountGroupMutation(c config, op Op, opts ...accountgroupOption) *AccountGroupMutation {
	m := &AccountGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetAccountID sets the "account_id" field.
func (m *AccountGroupMutation) SetAccountID(i int64) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountGroupMutation) AccountID() (r int64, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountGroupMutation) ResetAccountID() {
	m.account = nil
}

// SetGroupID sets the "group_id" field.
func (m *AccountGroupMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *AccountGroupMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *AccountGroupMutation) ResetGroupID() {
	m.group = nil
}

// SetPriority sets the "priority" field.
func (m *AccountGroupMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *AccountGroupMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// AddPriority adds i to the "priority" field.
func (m *AccountGroupMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *AccountGroupMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *AccountGroupMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *AccountGroupMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[accountgroup.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *AccountGroupMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *AccountGroupMutation) AccountIDs() (ids []int64) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *AccountGroupMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *AccountGroupMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[accountgroup.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *AccountGroupMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *AccountGroupMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *AccountGroupMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the AccountGroupMutation builder.
func (m *AccountGroupMutation) Where(ps ...predicate.AccountGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountGroup).
func (m *AccountGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountGroupMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.account != nil {
		fields = append(fields, accountgroup.FieldAccountID)
	}
	if m.group != nil {
		fields = append(fields, accountgroup.FieldGroupID)
	}
	if m.priority != nil {
		fields = append(fields, accountgroup.FieldPriority)
	}
	if m.created_at != nil {
		fields = append(fields, accountgroup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountgroup.FieldAccountID:
		return m.AccountID()
	case accountgroup.FieldGroupID:
		return m.GroupID()
	case accountgroup.FieldPriority:
		return m.Priority()
	case accountgroup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema AccountGroup does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountgroup.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountgroup.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case accountgroup.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case accountgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AccountGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountGroupMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, accountgroup.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountgroup.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountgroup.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown AccountGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountGroupMutation) ResetField(name string) error {
	switch name {
	case accountgroup.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountgroup.FieldGroupID:
		m.ResetGroupID()
		return nil
	case accountgroup.FieldPriority:
		m.ResetPriority()
		return nil
	case accountgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, accountgroup.EdgeAccount)
	}
	if m.group != nil {
		edges = append(edges, accountgroup.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountgroup.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case accountgroup.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, accountgroup.EdgeAccount)
	}
	if m.clearedgroup {
		edges = append(edges, accountgroup.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case accountgroup.EdgeAccount:
		return m.clearedaccount
	case accountgroup.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountGroupMutation) ClearEdge(name string) error {
	switch name {
	case accountgroup.EdgeAccount:
		m.ClearAccount()
		return nil
	case accountgroup.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountGroupMutation) ResetEdge(name string) error {
	switch name {
	case accountgroup.EdgeAccount:
		m.ResetAccount()
		return nil
	case accountgroup.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	name                     *string
	description              *string
	rate_multiplier          *float64
	addrate_multiplier       *float64
	is_exclusive             *bool
	status                   *string
	platform                 *string
	subscription_type        *string
	daily_limit_usd          *float64
	adddaily_limit_usd       *float64
	weekly_limit_usd         *float64
	addweekly_limit_usd      *float64
	monthly_limit_usd        *float64
	addmonthly_limit_usd     *float64
	default_validity_days    *int
	adddefault_validity_days *int
	clearedFields            map[string]struct{}
	api_keys                 map[int64]struct{}
	removedapi_keys          map[int64]struct{}
	clearedapi_keys          bool
	redeem_codes             map[int64]struct{}
	removedredeem_codes      map[int64]struct{}
	clearedredeem_codes      bool
	subscriptions            map[int64]struct{}
	removedsubscriptions     map[int64]struct{}
	clearedsubscriptions     bool
	usage_logs               map[int64]struct{}
	removedusage_logs        map[int64]struct{}
	clearedusage_logs        bool
	accounts                 map[int64]struct{}
	removedaccounts          map[int64]struct{}
	clearedaccounts          bool
	allowed_users            map[int64]struct{}
	removedallowed_users     map[int64]struct{}
	clearedallowed_users     bool
	done                     bool
	oldValue                 func(context.Context) (*Group, error)
	predicates               []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int64) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[group.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[group.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, group.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[group.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[group.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, group.FieldDescription)
}

// SetRateMultiplier sets the "rate_multiplier" field.
func (m *GroupMutation) SetRateMultiplier(f float64) {
	m.rate_multiplier = &f
	m.addrate_multiplier = nil
}

// RateMultiplier returns the value of the "rate_multiplier" field in the mutation.
func (m *GroupMutation) RateMultiplier() (r float64, exists bool) {
	v := m.rate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldRateMultiplier returns the old "rate_multiplier" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldRateMultiplier(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateMultiplier: %w", err)
	}
	return oldValue.RateMultiplier, nil
}

// AddRateMultiplier adds f to the "rate_multiplier" field.
func (m *GroupMutation) AddRateMultiplier(f float64) {
	if m.addrate_multiplier != nil {
		*m.addrate_multiplier += f
	} else {
		m.addrate_multiplier = &f
	}
}

// AddedRateMultiplier returns the value that was added to the "rate_multiplier" field in this mutation.
func (m *GroupMutation) AddedRateMultiplier() (r float64, exists bool) {
	v := m.addrate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// ResetRateMultiplier resets all changes to the "rate_multiplier" field.
func (m *GroupMutation) ResetRateMultiplier() {
	m.rate_multiplier = nil
	m.addrate_multiplier = nil
}

// SetIsExclusive sets the "is_exclusive" field.
func (m *GroupMutation) SetIsExclusive(b bool) {
	m.is_exclusive = &b
}

// IsExclusive returns the value of the "is_exclusive" field in the mutation.
func (m *GroupMutation) IsExclusive() (r bool, exists bool) {
	v := m.is_exclusive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsExclusive returns the old "is_exclusive" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldIsExclusive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsExclusive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsExclusive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsExclusive: %w", err)
	}
	return oldValue.IsExclusive, nil
}

// ResetIsExclusive resets all changes to the "is_exclusive" field.
func (m *GroupMutation) ResetIsExclusive() {
	m.is_exclusive = nil
}

// SetStatus sets the "status" field.
func (m *GroupMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *GroupMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GroupMutation) ResetStatus() {
	m.status = nil
}

// SetPlatform sets the "platform" field.
func (m *GroupMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *GroupMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *GroupMutation) ResetPlatform() {
	m.platform = nil
}

// SetSubscriptionType sets the "subscription_type" field.
func (m *GroupMutation) SetSubscriptionType(s string) {
	m.subscription_type = &s
}

// SubscriptionType returns the value of the "subscription_type" field in the mutation.
func (m *GroupMutation) SubscriptionType() (r string, exists bool) {
	v := m.subscription_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionType returns the old "subscription_type" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldSubscriptionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionType: %w", err)
	}
	return oldValue.SubscriptionType, nil
}

// ResetSubscriptionType resets all changes to the "subscription_type" field.
func (m *GroupMutation) ResetSubscriptionType() {
	m.subscription_type = nil
}

// SetDailyLimitUsd sets the "daily_limit_usd" field.
func (m *GroupMutation) SetDailyLimitUsd(f float64) {
	m.daily_limit_usd = &f
	m.adddaily_limit_usd = nil
}

// DailyLimitUsd returns the value of the "daily_limit_usd" field in the mutation.
func (m *GroupMutation) DailyLimitUsd() (r float64, exists bool) {
	v := m.daily_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyLimitUsd returns the old "daily_limit_usd" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDailyLimitUsd(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyLimitUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyLimitUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyLimitUsd: %w", err)
	}
	return oldValue.DailyLimitUsd, nil
}

// AddDailyLimitUsd adds f to the "daily_limit_usd" field.
func (m *GroupMutation) AddDailyLimitUsd(f float64) {
	if m.adddaily_limit_usd != nil {
		*m.adddaily_limit_usd += f
	} else {
		m.adddaily_limit_usd = &f
	}
}

// AddedDailyLimitUsd returns the value that was added to the "daily_limit_usd" field in this mutation.
func (m *GroupMutation) AddedDailyLimitUsd() (r float64, exists bool) {
	v := m.adddaily_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// ClearDailyLimitUsd clears the value of the "daily_limit_usd" field.
func (m *GroupMutation) ClearDailyLimitUsd() {
	m.daily_limit_usd = nil
	m.adddaily_limit_usd = nil
	m.clearedFields[group.FieldDailyLimitUsd] = struct{}{}
}

// DailyLimitUsdCleared returns if the "daily_limit_usd" field was cleared in this mutation.
func (m *GroupMutation) DailyLimitUsdCleared() bool {
	_, ok := m.clearedFields[group.FieldDailyLimitUsd]
	return ok
}

// ResetDailyLimitUsd resets all changes to the "daily_limit_usd" field.
func (m *GroupMutation) ResetDailyLimitUsd() {
	m.daily_limit_usd = nil
	m.adddaily_limit_usd = nil
	delete(m.clearedFields, group.FieldDailyLimitUsd)
}

// SetWeeklyLimitUsd sets the "weekly_limit_usd" field.
func (m *GroupMutation) SetWeeklyLimitUsd(f float64) {
	m.weekly_limit_usd = &f
	m.addweekly_limit_usd = nil
}

// WeeklyLimitUsd returns the value of the "weekly_limit_usd" field in the mutation.
func (m *GroupMutation) WeeklyLimitUsd() (r float64, exists bool) {
	v := m.weekly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldWeeklyLimitUsd returns the old "weekly_limit_usd" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldWeeklyLimitUsd(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeeklyLimitUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeeklyLimitUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeeklyLimitUsd: %w", err)
	}
	return oldValue.WeeklyLimitUsd, nil
}

// AddWeeklyLimitUsd adds f to the "weekly_limit_usd" field.
func (m *GroupMutation) AddWeeklyLimitUsd(f float64) {
	if m.addweekly_limit_usd != nil {
		*m.addweekly_limit_usd += f
	} else {
		m.addweekly_limit_usd = &f
	}
}

// AddedWeeklyLimitUsd returns the value that was added to the "weekly_limit_usd" field in this mutation.
func (m *GroupMutation) AddedWeeklyLimitUsd() (r float64, exists bool) {
	v := m.addweekly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeeklyLimitUsd clears the value of the "weekly_limit_usd" field.
func (m *GroupMutation) ClearWeeklyLimitUsd() {
	m.weekly_limit_usd = nil
	m.addweekly_limit_usd = nil
	m.clearedFields[group.FieldWeeklyLimitUsd] = struct{}{}
}

// WeeklyLimitUsdCleared returns if the "weekly_limit_usd" field was cleared in this mutation.
func (m *GroupMutation) WeeklyLimitUsdCleared() bool {
	_, ok := m.clearedFields[group.FieldWeeklyLimitUsd]
	return ok
}

// ResetWeeklyLimitUsd resets all changes to the "weekly_limit_usd" field.
func (m *GroupMutation) ResetWeeklyLimitUsd() {
	m.weekly_limit_usd = nil
	m.addweekly_limit_usd = nil
	delete(m.clearedFields, group.FieldWeeklyLimitUsd)
}

// SetMonthlyLimitUsd sets the "monthly_limit_usd" field.
func (m *GroupMutation) SetMonthlyLimitUsd(f float64) {
	m.monthly_limit_usd = &f
	m.addmonthly_limit_usd = nil
}

// MonthlyLimitUsd returns the value of the "monthly_limit_usd" field in the mutation.
func (m *GroupMutation) MonthlyLimitUsd() (r float64, exists bool) {
	v := m.monthly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyLimitUsd returns the old "monthly_limit_usd" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldMonthlyLimitUsd(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyLimitUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyLimitUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyLimitUsd: %w", err)
	}
	return oldValue.MonthlyLimitUsd, nil
}

// AddMonthlyLimitUsd adds f to the "monthly_limit_usd" field.
func (m *GroupMutation) AddMonthlyLimitUsd(f float64) {
	if m.addmonthly_limit_usd != nil {
		*m.addmonthly_limit_usd += f
	} else {
		m.addmonthly_limit_usd = &f
	}
}

// AddedMonthlyLimitUsd returns the value that was added to the "monthly_limit_usd" field in this mutation.
func (m *GroupMutation) AddedMonthlyLimitUsd() (r float64, exists bool) {
	v := m.addmonthly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// ClearMonthlyLimitUsd clears the value of the "monthly_limit_usd" field.
func (m *GroupMutation) ClearMonthlyLimitUsd() {
	m.monthly_limit_usd = nil
	m.addmonthly_limit_usd = nil
	m.clearedFields[group.FieldMonthlyLimitUsd] = struct{}{}
}

// MonthlyLimitUsdCleared returns if the "monthly_limit_usd" field was cleared in this mutation.
func (m *GroupMutation) MonthlyLimitUsdCleared() bool {
	_, ok := m.clearedFields[group.FieldMonthlyLimitUsd]
	return ok
}

// ResetMonthlyLimitUsd resets all changes to the "monthly_limit_usd" field.
func (m *GroupMutation) ResetMonthlyLimitUsd() {
	m.monthly_limit_usd = nil
	m.addmonthly_limit_usd = nil
	delete(m.clearedFields, group.FieldMonthlyLimitUsd)
}

// SetDefaultValidityDays sets the "default_validity_days" field.
func (m *GroupMutation) SetDefaultValidityDays(i int) {
	m.default_validity_days = &i
	m.adddefault_validity_days = nil
}

// DefaultValidityDays returns the value of the "default_validity_days" field in the mutation.
func (m *GroupMutation) DefaultValidityDays() (r int, exists bool) {
	v := m.default_validity_days
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultValidityDays returns the old "default_validity_days" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDefaultValidityDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultValidityDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultValidityDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultValidityDays: %w", err)
	}
	return oldValue.DefaultValidityDays, nil
}

// AddDefaultValidityDays adds i to the "default_validity_days" field.
func (m *GroupMutation) AddDefaultValidityDays(i int) {
	if m.adddefault_validity_days != nil {
		*m.adddefault_validity_days += i
	} else {
		m.adddefault_validity_days = &i
	}
}

// AddedDefaultValidityDays returns the value that was added to the "default_validity_days" field in this mutation.
func (m *GroupMutation) AddedDefaultValidityDays() (r int, exists bool) {
	v := m.adddefault_validity_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultValidityDays resets all changes to the "default_validity_days" field.
func (m *GroupMutation) ResetDefaultValidityDays() {
	m.default_validity_days = nil
	m.adddefault_validity_days = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *GroupMutation) AddAPIKeyIDs(ids ...int64) {
	if m.api_keys == nil {
		m.api_keys = make(map[int64]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *GroupMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *GroupMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *GroupMutation) RemoveAPIKeyIDs(ids ...int64) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *GroupMutation) RemovedAPIKeysIDs() (ids []int64) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *GroupMutation) APIKeysIDs() (ids []int64) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *GroupMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRedeemCodeIDs adds the "redeem_codes" edge to the RedeemCode entity by ids.
func (m *GroupMutation) AddRedeemCodeIDs(ids ...int64) {
	if m.redeem_codes == nil {
		m.redeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		m.redeem_codes[ids[i]] = struct{}{}
	}
}

// ClearRedeemCodes clears the "redeem_codes" edge to the RedeemCode entity.
func (m *GroupMutation) ClearRedeemCodes() {
	m.clearedredeem_codes = true
}

// RedeemCodesCleared reports if the "redeem_codes" edge to the RedeemCode entity was cleared.
func (m *GroupMutation) RedeemCodesCleared() bool {
	return m.clearedredeem_codes
}

// RemoveRedeemCodeIDs removes the "redeem_codes" edge to the RedeemCode entity by IDs.
func (m *GroupMutation) RemoveRedeemCodeIDs(ids ...int64) {
	if m.removedredeem_codes == nil {
		m.removedredeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.redeem_codes, ids[i])
		m.removedredeem_codes[ids[i]] = struct{}{}
	}
}

// RemovedRedeemCodes returns the removed IDs of the "redeem_codes" edge to the RedeemCode entity.
func (m *GroupMutation) RemovedRedeemCodesIDs() (ids []int64) {
	for id := range m.removedredeem_codes {
		ids = append(ids, id)
	}
	return
}

// RedeemCodesIDs returns the "redeem_codes" edge IDs in the mutation.
func (m *GroupMutation) RedeemCodesIDs() (ids []int64) {
	for id := range m.redeem_codes {
		ids = append(ids, id)
	}
	return
}

// ResetRedeemCodes resets all changes to the "redeem_codes" edge.
func (m *GroupMutation) ResetRedeemCodes() {
	m.redeem_codes = nil
	m.clearedredeem_codes = false
	m.removedredeem_codes = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the UserSubscription entity by ids.
func (m *GroupMutation) AddSubscriptionIDs(ids ...int64) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the UserSubscription entity.
func (m *GroupMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the UserSubscription entity was cleared.
func (m *GroupMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the UserSubscription entity by IDs.
func (m *GroupMutation) RemoveSubscriptionIDs(ids ...int64) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the UserSubscription entity.
func (m *GroupMutation) RemovedSubscriptionsIDs() (ids []int64) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *GroupMutation) SubscriptionsIDs() (ids []int64) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *GroupMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *GroupMutation) AddUsageLogIDs(ids ...int64) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *GroupMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *GroupMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *GroupMutation) RemoveUsageLogIDs(ids ...int64) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *GroupMutation) RemovedUsageLogsIDs() (ids []int64) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *GroupMutation) UsageLogsIDs() (ids []int64) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *GroupMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *GroupMutation) AddAccountIDs(ids ...int64) {
	if m.accounts == nil {
		m.accounts = make(map[int64]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *GroupMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *GroupMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *GroupMutation) RemoveAccountIDs(ids ...int64) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *GroupMutation) RemovedAccountsIDs() (ids []int64) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *GroupMutation) AccountsIDs() (ids []int64) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *GroupMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddAllowedUserIDs adds the "allowed_users" edge to the User entity by ids.
func (m *GroupMutation) AddAllowedUserIDs(ids ...int64) {
	if m.allowed_users == nil {
		m.allowed_users = make(map[int64]struct{})
	}
	for i := range ids {
		m.allowed_users[ids[i]] = struct{}{}
	}
}

// ClearAllowedUsers clears the "allowed_users" edge to the User entity.
func (m *GroupMutation) ClearAllowedUsers() {
	m.clearedallowed_users = true
}

// AllowedUsersCleared reports if the "allowed_users" edge to the User entity was cleared.
func (m *GroupMutation) AllowedUsersCleared() bool {
	return m.clearedallowed_users
}

// RemoveAllowedUserIDs removes the "allowed_users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveAllowedUserIDs(ids ...int64) {
	if m.removedallowed_users == nil {
		m.removedallowed_users = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allowed_users, ids[i])
		m.removedallowed_users[ids[i]] = struct{}{}
	}
}

// RemovedAllowedUsers returns the removed IDs of the "allowed_users" edge to the User entity.
func (m *GroupMutation) RemovedAllowedUsersIDs() (ids []int64) {
	for id := range m.removedallowed_users {
		ids = append(ids, id)
	}
	return
}

// AllowedUsersIDs returns the "allowed_users" edge IDs in the mutation.
func (m *GroupMutation) AllowedUsersIDs() (ids []int64) {
	for id := range m.allowed_users {
		ids = append(ids, id)
	}
	return
}

// ResetAllowedUsers resets all changes to the "allowed_users" edge.
func (m *GroupMutation) ResetAllowedUsers() {
	m.allowed_users = nil
	m.clearedallowed_users = false
	m.removedallowed_users = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.description != nil {
		fields = append(fields, group.FieldDescription)
	}
	if m.rate_multiplier != nil {
		fields = append(fields, group.FieldRateMultiplier)
	}
	if m.is_exclusive != nil {
		fields = append(fields, group.FieldIsExclusive)
	}
	if m.status != nil {
		fields = append(fields, group.FieldStatus)
	}
	if m.platform != nil {
		fields = append(fields, group.FieldPlatform)
	}
	if m.subscription_type != nil {
		fields = append(fields, group.FieldSubscriptionType)
	}
	if m.daily_limit_usd != nil {
		fields = append(fields, group.FieldDailyLimitUsd)
	}
	if m.weekly_limit_usd != nil {
		fields = append(fields, group.FieldWeeklyLimitUsd)
	}
	if m.monthly_limit_usd != nil {
		fields = append(fields, group.FieldMonthlyLimitUsd)
	}
	if m.default_validity_days != nil {
		fields = append(fields, group.FieldDefaultValidityDays)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	case group.FieldDeletedAt:
		return m.DeletedAt()
	case group.FieldName:
		return m.Name()
	case group.FieldDescription:
		return m.Description()
	case group.FieldRateMultiplier:
		return m.RateMultiplier()
	case group.FieldIsExclusive:
		return m.IsExclusive()
	case group.FieldStatus:
		return m.Status()
	case group.FieldPlatform:
		return m.Platform()
	case group.FieldSubscriptionType:
		return m.SubscriptionType()
	case group.FieldDailyLimitUsd:
		return m.DailyLimitUsd()
	case group.FieldWeeklyLimitUsd:
		return m.WeeklyLimitUsd()
	case group.FieldMonthlyLimitUsd:
		return m.MonthlyLimitUsd()
	case group.FieldDefaultValidityDays:
		return m.DefaultValidityDays()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case group.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldDescription:
		return m.OldDescription(ctx)
	case group.FieldRateMultiplier:
		return m.OldRateMultiplier(ctx)
	case group.FieldIsExclusive:
		return m.OldIsExclusive(ctx)
	case group.FieldStatus:
		return m.OldStatus(ctx)
	case group.FieldPlatform:
		return m.OldPlatform(ctx)
	case group.FieldSubscriptionType:
		return m.OldSubscriptionType(ctx)
	case group.FieldDailyLimitUsd:
		return m.OldDailyLimitUsd(ctx)
	case group.FieldWeeklyLimitUsd:
		return m.OldWeeklyLimitUsd(ctx)
	case group.FieldMonthlyLimitUsd:
		return m.OldMonthlyLimitUsd(ctx)
	case group.FieldDefaultValidityDays:
		return m.OldDefaultValidityDays(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case group.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case group.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateMultiplier(v)
		return nil
	case group.FieldIsExclusive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsExclusive(v)
		return nil
	case group.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case group.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case group.FieldSubscriptionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionType(v)
		return nil
	case group.FieldDailyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyLimitUsd(v)
		return nil
	case group.FieldWeeklyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeeklyLimitUsd(v)
		return nil
	case group.FieldMonthlyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyLimitUsd(v)
		return nil
	case group.FieldDefaultValidityDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultValidityDays(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	var fields []string
	if m.addrate_multiplier != nil {
		fields = append(fields, group.FieldRateMultiplier)
	}
	if m.adddaily_limit_usd != nil {
		fields = append(fields, group.FieldDailyLimitUsd)
	}
	if m.addweekly_limit_usd != nil {
		fields = append(fields, group.FieldWeeklyLimitUsd)
	}
	if m.addmonthly_limit_usd != nil {
		fields = append(fields, group.FieldMonthlyLimitUsd)
	}
	if m.adddefault_validity_days != nil {
		fields = append(fields, group.FieldDefaultValidityDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case group.FieldRateMultiplier:
		return m.AddedRateMultiplier()
	case group.FieldDailyLimitUsd:
		return m.AddedDailyLimitUsd()
	case group.FieldWeeklyLimitUsd:
		return m.AddedWeeklyLimitUsd()
	case group.FieldMonthlyLimitUsd:
		return m.AddedMonthlyLimitUsd()
	case group.FieldDefaultValidityDays:
		return m.AddedDefaultValidityDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case group.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRateMultiplier(v)
		return nil
	case group.FieldDailyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyLimitUsd(v)
		return nil
	case group.FieldWeeklyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeeklyLimitUsd(v)
		return nil
	case group.FieldMonthlyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonthlyLimitUsd(v)
		return nil
	case group.FieldDefaultValidityDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultValidityDays(v)
		return nil
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(group.FieldDeletedAt) {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.FieldCleared(group.FieldDescription) {
		fields = append(fields, group.FieldDescription)
	}
	if m.FieldCleared(group.FieldDailyLimitUsd) {
		fields = append(fields, group.FieldDailyLimitUsd)
	}
	if m.FieldCleared(group.FieldWeeklyLimitUsd) {
		fields = append(fields, group.FieldWeeklyLimitUsd)
	}
	if m.FieldCleared(group.FieldMonthlyLimitUsd) {
		fields = append(fields, group.FieldMonthlyLimitUsd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	switch name {
	case group.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case group.FieldDescription:
		m.ClearDescription()
		return nil
	case group.FieldDailyLimitUsd:
		m.ClearDailyLimitUsd()
		return nil
	case group.FieldWeeklyLimitUsd:
		m.ClearWeeklyLimitUsd()
		return nil
	case group.FieldMonthlyLimitUsd:
		m.ClearMonthlyLimitUsd()
		return nil
	}
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case group.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldDescription:
		m.ResetDescription()
		return nil
	case group.FieldRateMultiplier:
		m.ResetRateMultiplier()
		return nil
	case group.FieldIsExclusive:
		m.ResetIsExclusive()
		return nil
	case group.FieldStatus:
		m.ResetStatus()
		return nil
	case group.FieldPlatform:
		m.ResetPlatform()
		return nil
	case group.FieldSubscriptionType:
		m.ResetSubscriptionType()
		return nil
	case group.FieldDailyLimitUsd:
		m.ResetDailyLimitUsd()
		return nil
	case group.FieldWeeklyLimitUsd:
		m.ResetWeeklyLimitUsd()
		return nil
	case group.FieldMonthlyLimitUsd:
		m.ResetMonthlyLimitUsd()
		return nil
	case group.FieldDefaultValidityDays:
		m.ResetDefaultValidityDays()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.api_keys != nil {
		edges = append(edges, group.EdgeAPIKeys)
	}
	if m.redeem_codes != nil {
		edges = append(edges, group.EdgeRedeemCodes)
	}
	if m.subscriptions != nil {
		edges = append(edges, group.EdgeSubscriptions)
	}
	if m.usage_logs != nil {
		edges = append(edges, group.EdgeUsageLogs)
	}
	if m.accounts != nil {
		edges = append(edges, group.EdgeAccounts)
	}
	if m.allowed_users != nil {
		edges = append(edges, group.EdgeAllowedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.redeem_codes))
		for id := range m.redeem_codes {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAllowedUsers:
		ids := make([]ent.Value, 0, len(m.allowed_users))
		for id := range m.allowed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedapi_keys != nil {
		edges = append(edges, group.EdgeAPIKeys)
	}
	if m.removedredeem_codes != nil {
		edges = append(edges, group.EdgeRedeemCodes)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, group.EdgeSubscriptions)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, group.EdgeUsageLogs)
	}
	if m.removedaccounts != nil {
		edges = append(edges, group.EdgeAccounts)
	}
	if m.removedallowed_users != nil {
		edges = append(edges, group.EdgeAllowedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.removedredeem_codes))
		for id := range m.removedredeem_codes {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAllowedUsers:
		ids := make([]ent.Value, 0, len(m.removedallowed_users))
		for id := range m.removedallowed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedapi_keys {
		edges = append(edges, group.EdgeAPIKeys)
	}
	if m.clearedredeem_codes {
		edges = append(edges, group.EdgeRedeemCodes)
	}
	if m.clearedsubscriptions {
		edges = append(edges, group.EdgeSubscriptions)
	}
	if m.clearedusage_logs {
		edges = append(edges, group.EdgeUsageLogs)
	}
	if m.clearedaccounts {
		edges = append(edges, group.EdgeAccounts)
	}
	if m.clearedallowed_users {
		edges = append(edges, group.EdgeAllowedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeAPIKeys:
		return m.clearedapi_keys
	case group.EdgeRedeemCodes:
		return m.clearedredeem_codes
	case group.EdgeSubscriptions:
		return m.clearedsubscriptions
	case group.EdgeUsageLogs:
		return m.clearedusage_logs
	case group.EdgeAccounts:
		return m.clearedaccounts
	case group.EdgeAllowedUsers:
		return m.clearedallowed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case group.EdgeRedeemCodes:
		m.ResetRedeemCodes()
		return nil
	case group.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case group.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case group.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case group.EdgeAllowedUsers:
		m.ResetAllowedUsers()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// ProxyMutation represents an operation that mutates the Proxy nodes in the graph.
type ProxyMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	name            *string
	protocol        *string
	host            *string
	port            *int
	addport         *int
	username        *string
	password        *string
	status          *string
	clearedFields   map[string]struct{}
	accounts        map[int64]struct{}
	removedaccounts map[int64]struct{}
	clearedaccounts bool
	done            bool
	oldValue        func(context.Context) (*Proxy, error)
	predicates      []predicate.Proxy
}

var _ ent.Mutation = (*ProxyMutation)(nil)

// proxyOption allows management of the mutation configuration using functional options.
type proxyOption func(*ProxyMutation)

// newProxyMutation creates new mutation for the Proxy entity.
func newProxyMutation(c config, op Op, opts ...proxyOption) *ProxyMutation {
	m := &ProxyMutation{
		config:        c,
		op:            op,
		typ:           TypeProxy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProxyID sets the ID field of the mutation.
func withProxyID(id int64) proxyOption {
	return func(m *ProxyMutation) {
		var (
			err   error
			once  sync.Once
			value *Proxy
		)
		m.oldValue = func(ctx context.Context) (*Proxy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Proxy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProxy sets the old Proxy of the mutation.
func withProxy(node *Proxy) proxyOption {
	return func(m *ProxyMutation) {
		m.oldValue = func(context.Context) (*Proxy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProxyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProxyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProxyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProxyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Proxy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProxyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProxyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProxyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProxyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProxyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProxyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProxyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProxyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProxyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[proxy.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProxyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[proxy.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProxyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, proxy.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ProxyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProxyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProxyMutation) ResetName() {
	m.name = nil
}

// SetProtocol sets the "protocol" field.
func (m *ProxyMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *ProxyMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *ProxyMutation) ResetProtocol() {
	m.protocol = nil
}

// SetHost sets the "host" field.
func (m *ProxyMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *ProxyMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *ProxyMutation) ResetHost() {
	m.host = nil
}

// SetPort sets the "port" field.
func (m *ProxyMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *ProxyMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *ProxyMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *ProxyMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *ProxyMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetUsername sets the "username" field.
func (m *ProxyMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ProxyMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *ProxyMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[proxy.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *ProxyMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[proxy.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *ProxyMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, proxy.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *ProxyMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ProxyMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *ProxyMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[proxy.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *ProxyMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[proxy.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *ProxyMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, proxy.FieldPassword)
}

// SetStatus sets the "status" field.
func (m *ProxyMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProxyMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProxyMutation) ResetStatus() {
	m.status = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *ProxyMutation) AddAccountIDs(ids ...int64) {
	if m.accounts == nil {
		m.accounts = make(map[int64]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *ProxyMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *ProxyMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *ProxyMutation) RemoveAccountIDs(ids ...int64) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *ProxyMutation) RemovedAccountsIDs() (ids []int64) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *ProxyMutation) AccountsIDs() (ids []int64) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *ProxyMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// Where appends a list predicates to the ProxyMutation builder.
func (m *ProxyMutation) Where(ps ...predicate.Proxy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProxyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProxyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Proxy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProxyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProxyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Proxy).
func (m *ProxyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProxyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, proxy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, proxy.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, proxy.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, proxy.FieldName)
	}
	if m.protocol != nil {
		fields = append(fields, proxy.FieldProtocol)
	}
	if m.host != nil {
		fields = append(fields, proxy.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, proxy.FieldPort)
	}
	if m.username != nil {
		fields = append(fields, proxy.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, proxy.FieldPassword)
	}
	if m.status != nil {
		fields = append(fields, proxy.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProxyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.CreatedAt()
	case proxy.FieldUpdatedAt:
		return m.UpdatedAt()
	case proxy.FieldDeletedAt:
		return m.DeletedAt()
	case proxy.FieldName:
		return m.Name()
	case proxy.FieldProtocol:
		return m.Protocol()
	case proxy.FieldHost:
		return m.Host()
	case proxy.FieldPort:
		return m.Port()
	case proxy.FieldUsername:
		return m.Username()
	case proxy.FieldPassword:
		return m.Password()
	case proxy.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProxyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case proxy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case proxy.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case proxy.FieldName:
		return m.OldName(ctx)
	case proxy.FieldProtocol:
		return m.OldProtocol(ctx)
	case proxy.FieldHost:
		return m.OldHost(ctx)
	case proxy.FieldPort:
		return m.OldPort(ctx)
	case proxy.FieldUsername:
		return m.OldUsername(ctx)
	case proxy.FieldPassword:
		return m.OldPassword(ctx)
	case proxy.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Proxy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case proxy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case proxy.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case proxy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case proxy.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case proxy.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case proxy.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case proxy.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case proxy.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case proxy.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProxyMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, proxy.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProxyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProxyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(proxy.FieldDeletedAt) {
		fields = append(fields, proxy.FieldDeletedAt)
	}
	if m.FieldCleared(proxy.FieldUsername) {
		fields = append(fields, proxy.FieldUsername)
	}
	if m.FieldCleared(proxy.FieldPassword) {
		fields = append(fields, proxy.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProxyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProxyMutation) ClearField(name string) error {
	switch name {
	case proxy.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case proxy.FieldUsername:
		m.ClearUsername()
		return nil
	case proxy.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Proxy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProxyMutation) ResetField(name string) error {
	switch name {
	case proxy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case proxy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case proxy.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case proxy.FieldName:
		m.ResetName()
		return nil
	case proxy.FieldProtocol:
		m.ResetProtocol()
		return nil
	case proxy.FieldHost:
		m.ResetHost()
		return nil
	case proxy.FieldPort:
		m.ResetPort()
		return nil
	case proxy.FieldUsername:
		m.ResetUsername()
		return nil
	case proxy.FieldPassword:
		m.ResetPassword()
		return nil
	case proxy.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProxyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.accounts != nil {
		edges = append(edges, proxy.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProxyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proxy.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProxyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedaccounts != nil {
		edges = append(edges, proxy.EdgeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProxyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case proxy.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProxyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccounts {
		edges = append(edges, proxy.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProxyMutation) EdgeCleared(name string) bool {
	switch name {
	case proxy.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProxyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Proxy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProxyMutation) ResetEdge(name string) error {
	switch name {
	case proxy.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown Proxy edge %s", name)
}

// RedeemCodeMutation represents an operation that mutates the RedeemCode nodes in the graph.
type RedeemCodeMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	code             *string
	_type            *string
	value            *float64
	addvalue         *float64
	status           *string
	used_at          *time.Time
	notes            *string
	created_at       *time.Time
	validity_days    *int
	addvalidity_days *int
	clearedFields    map[string]struct{}
	user             *int64
	cleareduser      bool
	group            *int64
	clearedgroup     bool
	done             bool
	oldValue         func(context.Context) (*RedeemCode, error)
	predicates       []predicate.RedeemCode
}

var _ ent.Mutation = (*RedeemCodeMutation)(nil)

// redeemcodeOption allows management of the mutation configuration using functional options.
type redeemcodeOption func(*RedeemCodeMutation)

// newRedeemCodeMutation creates new mutation for the RedeemCode entity.
func newRedeemCodeMutation(c config, op Op, opts ...redeemcodeOption) *RedeemCodeMutation {
	m := &RedeemCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeRedeemCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRedeemCodeID sets the ID field of the mutation.
func withRedeemCodeID(id int64) redeemcodeOption {
	return func(m *RedeemCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *RedeemCode
		)
		m.oldValue = func(ctx context.Context) (*RedeemCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RedeemCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRedeemCode sets the old RedeemCode of the mutation.
func withRedeemCode(node *RedeemCode) redeemcodeOption {
	return func(m *RedeemCodeMutation) {
		m.oldValue = func(context.Context) (*RedeemCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RedeemCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RedeemCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RedeemCodeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RedeemCodeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RedeemCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *RedeemCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RedeemCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RedeemCodeMutation) ResetCode() {
	m.code = nil
}

// SetType sets the "type" field.
func (m *RedeemCodeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RedeemCodeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RedeemCodeMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *RedeemCodeMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *RedeemCodeMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *RedeemCodeMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *RedeemCodeMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *RedeemCodeMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetStatus sets the "status" field.
func (m *RedeemCodeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *RedeemCodeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RedeemCodeMutation) ResetStatus() {
	m.status = nil
}

// SetUsedBy sets the "used_by" field.
func (m *RedeemCodeMutation) SetUsedBy(i int64) {
	m.user = &i
}

// UsedBy returns the value of the "used_by" field in the mutation.
func (m *RedeemCodeMutation) UsedBy() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedBy returns the old "used_by" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldUsedBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedBy: %w", err)
	}
	return oldValue.UsedBy, nil
}

// ClearUsedBy clears the value of the "used_by" field.
func (m *RedeemCodeMutation) ClearUsedBy() {
	m.user = nil
	m.clearedFields[redeemcode.FieldUsedBy] = struct{}{}
}

// UsedByCleared returns if the "used_by" field was cleared in this mutation.
func (m *RedeemCodeMutation) UsedByCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldUsedBy]
	return ok
}

// ResetUsedBy resets all changes to the "used_by" field.
func (m *RedeemCodeMutation) ResetUsedBy() {
	m.user = nil
	delete(m.clearedFields, redeemcode.FieldUsedBy)
}

// SetUsedAt sets the "used_at" field.
func (m *RedeemCodeMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *RedeemCodeMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *RedeemCodeMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[redeemcode.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *RedeemCodeMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *RedeemCodeMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, redeemcode.FieldUsedAt)
}

// SetNotes sets the "notes" field.
func (m *RedeemCodeMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *RedeemCodeMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *RedeemCodeMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[redeemcode.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *RedeemCodeMutation) NotesCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *RedeemCodeMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, redeemcode.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *RedeemCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RedeemCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RedeemCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetGroupID sets the "group_id" field.
func (m *RedeemCodeMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *RedeemCodeMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldGroupID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *RedeemCodeMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[redeemcode.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *RedeemCodeMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *RedeemCodeMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, redeemcode.FieldGroupID)
}

// SetValidityDays sets the "validity_days" field.
func (m *RedeemCodeMutation) SetValidityDays(i int) {
	m.validity_days = &i
	m.addvalidity_days = nil
}

// ValidityDays returns the value of the "validity_days" field in the mutation.
func (m *RedeemCodeMutation) ValidityDays() (r int, exists bool) {
	v := m.validity_days
	if v == nil {
		return
	}
	return *v, true
}

// OldValidityDays returns the old "validity_days" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldValidityDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidityDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidityDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidityDays: %w", err)
	}
	return oldValue.ValidityDays, nil
}

// AddValidityDays adds i to the "validity_days" field.
func (m *RedeemCodeMutation) AddValidityDays(i int) {
	if m.addvalidity_days != nil {
		*m.addvalidity_days += i
	} else {
		m.addvalidity_days = &i
	}
}

// AddedValidityDays returns the value that was added to the "validity_days" field in this mutation.
func (m *RedeemCodeMutation) AddedValidityDays() (r int, exists bool) {
	v := m.addvalidity_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetValidityDays resets all changes to the "validity_days" field.
func (m *RedeemCodeMutation) ResetValidityDays() {
	m.validity_days = nil
	m.addvalidity_days = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *RedeemCodeMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *RedeemCodeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[redeemcode.FieldUsedBy] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RedeemCodeMutation) UserCleared() bool {
	return m.UsedByCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RedeemCodeMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RedeemCodeMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RedeemCodeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *RedeemCodeMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[redeemcode.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *RedeemCodeMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *RedeemCodeMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *RedeemCodeMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the RedeemCodeMutation builder.
func (m *RedeemCodeMutation) Where(ps ...predicate.RedeemCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RedeemCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RedeemCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RedeemCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RedeemCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RedeemCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RedeemCode).
func (m *RedeemCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RedeemCodeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.code != nil {
		fields = append(fields, redeemcode.FieldCode)
	}
	if m._type != nil {
		fields = append(fields, redeemcode.FieldType)
	}
	if m.value != nil {
		fields = append(fields, redeemcode.FieldValue)
	}
	if m.status != nil {
		fields = append(fields, redeemcode.FieldStatus)
	}
	if m.user != nil {
		fields = append(fields, redeemcode.FieldUsedBy)
	}
	if m.used_at != nil {
		fields = append(fields, redeemcode.FieldUsedAt)
	}
	if m.notes != nil {
		fields = append(fields, redeemcode.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, redeemcode.FieldCreatedAt)
	}
	if m.group != nil {
		fields = append(fields, redeemcode.FieldGroupID)
	}
	if m.validity_days != nil {
		fields = append(fields, redeemcode.FieldValidityDays)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RedeemCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case redeemcode.FieldCode:
		return m.Code()
	case redeemcode.FieldType:
		return m.GetType()
	case redeemcode.FieldValue:
		return m.Value()
	case redeemcode.FieldStatus:
		return m.Status()
	case redeemcode.FieldUsedBy:
		return m.UsedBy()
	case redeemcode.FieldUsedAt:
		return m.UsedAt()
	case redeemcode.FieldNotes:
		return m.Notes()
	case redeemcode.FieldCreatedAt:
		return m.CreatedAt()
	case redeemcode.FieldGroupID:
		return m.GroupID()
	case redeemcode.FieldValidityDays:
		return m.ValidityDays()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RedeemCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case redeemcode.FieldCode:
		return m.OldCode(ctx)
	case redeemcode.FieldType:
		return m.OldType(ctx)
	case redeemcode.FieldValue:
		return m.OldValue(ctx)
	case redeemcode.FieldStatus:
		return m.OldStatus(ctx)
	case redeemcode.FieldUsedBy:
		return m.OldUsedBy(ctx)
	case redeemcode.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case redeemcode.FieldNotes:
		return m.OldNotes(ctx)
	case redeemcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case redeemcode.FieldGroupID:
		return m.OldGroupID(ctx)
	case redeemcode.FieldValidityDays:
		return m.OldValidityDays(ctx)
	}
	return nil, fmt.Errorf("unknown RedeemCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RedeemCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case redeemcode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case redeemcode.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case redeemcode.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case redeemcode.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case redeemcode.FieldUsedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedBy(v)
		return nil
	case redeemcode.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case redeemcode.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case redeemcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case redeemcode.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case redeemcode.FieldValidityDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidityDays(v)
		return nil
	}
	return fmt.Errorf("unknown RedeemCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RedeemCodeMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, redeemcode.FieldValue)
	}
	if m.addvalidity_days != nil {
		fields = append(fields, redeemcode.FieldValidityDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RedeemCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case redeemcode.FieldValue:
		return m.AddedValue()
	case redeemcode.FieldValidityDays:
		return m.AddedValidityDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RedeemCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case redeemcode.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case redeemcode.FieldValidityDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidityDays(v)
		return nil
	}
	return fmt.Errorf("unknown RedeemCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RedeemCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(redeemcode.FieldUsedBy) {
		fields = append(fields, redeemcode.FieldUsedBy)
	}
	if m.FieldCleared(redeemcode.FieldUsedAt) {
		fields = append(fields, redeemcode.FieldUsedAt)
	}
	if m.FieldCleared(redeemcode.FieldNotes) {
		fields = append(fields, redeemcode.FieldNotes)
	}
	if m.FieldCleared(redeemcode.FieldGroupID) {
		fields = append(fields, redeemcode.FieldGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RedeemCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RedeemCodeMutation) ClearField(name string) error {
	switch name {
	case redeemcode.FieldUsedBy:
		m.ClearUsedBy()
		return nil
	case redeemcode.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case redeemcode.FieldNotes:
		m.ClearNotes()
		return nil
	case redeemcode.FieldGroupID:
		m.ClearGroupID()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RedeemCodeMutation) ResetField(name string) error {
	switch name {
	case redeemcode.FieldCode:
		m.ResetCode()
		return nil
	case redeemcode.FieldType:
		m.ResetType()
		return nil
	case redeemcode.FieldValue:
		m.ResetValue()
		return nil
	case redeemcode.FieldStatus:
		m.ResetStatus()
		return nil
	case redeemcode.FieldUsedBy:
		m.ResetUsedBy()
		return nil
	case redeemcode.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case redeemcode.FieldNotes:
		m.ResetNotes()
		return nil
	case redeemcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case redeemcode.FieldGroupID:
		m.ResetGroupID()
		return nil
	case redeemcode.FieldValidityDays:
		m.ResetValidityDays()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RedeemCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, redeemcode.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, redeemcode.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RedeemCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case redeemcode.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case redeemcode.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RedeemCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RedeemCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RedeemCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, redeemcode.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, redeemcode.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RedeemCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case redeemcode.EdgeUser:
		return m.cleareduser
	case redeemcode.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RedeemCodeMutation) ClearEdge(name string) error {
	switch name {
	case redeemcode.EdgeUser:
		m.ClearUser()
		return nil
	case redeemcode.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RedeemCodeMutation) ResetEdge(name string) error {
	switch name {
	case redeemcode.EdgeUser:
		m.ResetUser()
		return nil
	case redeemcode.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	key           *string
	value         *string
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int64) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, setting.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldKey:
		return m.Key()
	case setting.FieldValue:
		return m.Value()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldKey:
		return m.OldKey(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldKey:
		m.ResetKey()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// UsageLogMutation represents an operation that mutates the UsageLog nodes in the graph.
type UsageLogMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	request_id                  *string
	model                       *string
	input_tokens                *int
	addinput_tokens             *int
	output_tokens               *int
	addoutput_tokens            *int
	cache_creation_tokens       *int
	addcache_creation_tokens    *int
	cache_read_tokens           *int
	addcache_read_tokens        *int
	cache_creation_5m_tokens    *int
	addcache_creation_5m_tokens *int
	cache_creation_1h_tokens    *int
	addcache_creation_1h_tokens *int
	input_cost                  *float64
	addinput_cost               *float64
	output_cost                 *float64
	addoutput_cost              *float64
	cache_creation_cost         *float64
	addcache_creation_cost      *float64
	cache_read_cost             *float64
	addcache_read_cost          *float64
	total_cost                  *float64
	addtotal_cost               *float64
	actual_cost                 *float64
	addactual_cost              *float64
	rate_multiplier             *float64
	addrate_multiplier          *float64
	billing_type                *int8
	addbilling_type             *int8
	stream                      *bool
	duration_ms                 *int
	addduration_ms              *int
	first_token_ms              *int
	addfirst_token_ms           *int
	created_at                  *time.Time
	clearedFields               map[string]struct{}
	user                        *int64
	cleareduser                 bool
	api_key                     *int64
	clearedapi_key              bool
	account                     *int64
	clearedaccount              bool
	group                       *int64
	clearedgroup                bool
	subscription                *int64
	clearedsubscription         bool
	done                        bool
	oldValue                    func(context.Context) (*UsageLog, error)
	predicates                  []predicate.UsageLog
}

var _ ent.Mutation = (*UsageLogMutation)(nil)

// usagelogOption allows management of the mutation configuration using functional options.
type usagelogOption func(*UsageLogMutation)

// newUsageLogMutation creates new mutation for the UsageLog entity.
func newUsageLogMutation(c config, op Op, opts ...usagelogOption) *UsageLogMutation {
	m := &UsageLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageLogID sets the ID field of the mutation.
func withUsageLogID(id int64) usagelogOption {
	return func(m *UsageLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageLog
		)
		m.oldValue = func(ctx context.Context) (*UsageLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageLog sets the old UsageLog of the mutation.
func withUsageLog(node *UsageLog) usagelogOption {
	return func(m *UsageLogMutation) {
		m.oldValue = func(context.Context) (*UsageLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UsageLogMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UsageLogMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UsageLogMutation) ResetUserID() {
	m.user = nil
}

// SetAPIKeyID sets the "api_key_id" field.
func (m *UsageLogMutation) SetAPIKeyID(i int64) {
	m.api_key = &i
}

// APIKeyID returns the value of the "api_key_id" field in the mutation.
func (m *UsageLogMutation) APIKeyID() (r int64, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKeyID returns the old "api_key_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldAPIKeyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKeyID: %w", err)
	}
	return oldValue.APIKeyID, nil
}

// ResetAPIKeyID resets all changes to the "api_key_id" field.
func (m *UsageLogMutation) ResetAPIKeyID() {
	m.api_key = nil
}

// SetAccountID sets the "account_id" field.
func (m *UsageLogMutation) SetAccountID(i int64) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *UsageLogMutation) AccountID() (r int64, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *UsageLogMutation) ResetAccountID() {
	m.account = nil
}

// SetRequestID sets the "request_id" field.
func (m *UsageLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *UsageLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *UsageLogMutation) ResetRequestID() {
	m.request_id = nil
}

// SetModel sets the "model" field.
func (m *UsageLogMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *UsageLogMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *UsageLogMutation) ResetModel() {
	m.model = nil
}

// SetGroupID sets the "group_id" field.
func (m *UsageLogMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *UsageLogMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldGroupID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *UsageLogMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[usagelog.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *UsageLogMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *UsageLogMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, usagelog.FieldGroupID)
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *UsageLogMutation) SetSubscriptionID(i int64) {
	m.subscription = &i
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *UsageLogMutation) SubscriptionID() (r int64, exists bool) {
	v := m.subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldSubscriptionID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ClearSubscriptionID clears the value of the "subscription_id" field.
func (m *UsageLogMutation) ClearSubscriptionID() {
	m.subscription = nil
	m.clearedFields[usagelog.FieldSubscriptionID] = struct{}{}
}

// SubscriptionIDCleared returns if the "subscription_id" field was cleared in this mutation.
func (m *UsageLogMutation) SubscriptionIDCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldSubscriptionID]
	return ok
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *UsageLogMutation) ResetSubscriptionID() {
	m.subscription = nil
	delete(m.clearedFields, usagelog.FieldSubscriptionID)
}

// SetInputTokens sets the "input_tokens" field.
func (m *UsageLogMutation) SetInputTokens(i int) {
	m.input_tokens = &i
	m.addinput_tokens = nil
}

// InputTokens returns the value of the "input_tokens" field in the mutation.
func (m *UsageLogMutation) InputTokens() (r int, exists bool) {
	v := m.input_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldInputTokens returns the old "input_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldInputTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputTokens: %w", err)
	}
	return oldValue.InputTokens, nil
}

// AddInputTokens adds i to the "input_tokens" field.
func (m *UsageLogMutation) AddInputTokens(i int) {
	if m.addinput_tokens != nil {
		*m.addinput_tokens += i
	} else {
		m.addinput_tokens = &i
	}
}

// AddedInputTokens returns the value that was added to the "input_tokens" field in this mutation.
func (m *UsageLogMutation) AddedInputTokens() (r int, exists bool) {
	v := m.addinput_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetInputTokens resets all changes to the "input_tokens" field.
func (m *UsageLogMutation) ResetInputTokens() {
	m.input_tokens = nil
	m.addinput_tokens = nil
}

// SetOutputTokens sets the "output_tokens" field.
func (m *UsageLogMutation) SetOutputTokens(i int) {
	m.output_tokens = &i
	m.addoutput_tokens = nil
}

// OutputTokens returns the value of the "output_tokens" field in the mutation.
func (m *UsageLogMutation) OutputTokens() (r int, exists bool) {
	v := m.output_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputTokens returns the old "output_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldOutputTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputTokens: %w", err)
	}
	return oldValue.OutputTokens, nil
}

// AddOutputTokens adds i to the "output_tokens" field.
func (m *UsageLogMutation) AddOutputTokens(i int) {
	if m.addoutput_tokens != nil {
		*m.addoutput_tokens += i
	} else {
		m.addoutput_tokens = &i
	}
}

// AddedOutputTokens returns the value that was added to the "output_tokens" field in this mutation.
func (m *UsageLogMutation) AddedOutputTokens() (r int, exists bool) {
	v := m.addoutput_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutputTokens resets all changes to the "output_tokens" field.
func (m *UsageLogMutation) ResetOutputTokens() {
	m.output_tokens = nil
	m.addoutput_tokens = nil
}

// SetCacheCreationTokens sets the "cache_creation_tokens" field.
func (m *UsageLogMutation) SetCacheCreationTokens(i int) {
	m.cache_creation_tokens = &i
	m.addcache_creation_tokens = nil
}

// CacheCreationTokens returns the value of the "cache_creation_tokens" field in the mutation.
func (m *UsageLogMutation) CacheCreationTokens() (r int, exists bool) {
	v := m.cache_creation_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheCreationTokens returns the old "cache_creation_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheCreationTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheCreationTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheCreationTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheCreationTokens: %w", err)
	}
	return oldValue.CacheCreationTokens, nil
}

// AddCacheCreationTokens adds i to the "cache_creation_tokens" field.
func (m *UsageLogMutation) AddCacheCreationTokens(i int) {
	if m.addcache_creation_tokens != nil {
		*m.addcache_creation_tokens += i
	} else {
		m.addcache_creation_tokens = &i
	}
}

// AddedCacheCreationTokens returns the value that was added to the "cache_creation_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCacheCreationTokens() (r int, exists bool) {
	v := m.addcache_creation_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheCreationTokens resets all changes to the "cache_creation_tokens" field.
func (m *UsageLogMutation) ResetCacheCreationTokens() {
	m.cache_creation_tokens = nil
	m.addcache_creation_tokens = nil
}

// SetCacheReadTokens sets the "cache_read_tokens" field.
func (m *UsageLogMutation) SetCacheReadTokens(i int) {
	m.cache_read_tokens = &i
	m.addcache_read_tokens = nil
}

// CacheReadTokens returns the value of the "cache_read_tokens" field in the mutation.
func (m *UsageLogMutation) CacheReadTokens() (r int, exists bool) {
	v := m.cache_read_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheReadTokens returns the old "cache_read_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheReadTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheReadTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheReadTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheReadTokens: %w", err)
	}
	return oldValue.CacheReadTokens, nil
}

// AddCacheReadTokens adds i to the "cache_read_tokens" field.
func (m *UsageLogMutation) AddCacheReadTokens(i int) {
	if m.addcache_read_tokens != nil {
		*m.addcache_read_tokens += i
	} else {
		m.addcache_read_tokens = &i
	}
}

// AddedCacheReadTokens returns the value that was added to the "cache_read_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCacheReadTokens() (r int, exists bool) {
	v := m.addcache_read_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheReadTokens resets all changes to the "cache_read_tokens" field.
func (m *UsageLogMutation) ResetCacheReadTokens() {
	m.cache_read_tokens = nil
	m.addcache_read_tokens = nil
}

// SetCacheCreation5mTokens sets the "cache_creation_5m_tokens" field.
func (m *UsageLogMutation) SetCacheCreation5mTokens(i int) {
	m.cache_creation_5m_tokens = &i
	m.addcache_creation_5m_tokens = nil
}

// CacheCreation5mTokens returns the value of the "cache_creation_5m_tokens" field in the mutation.
func (m *UsageLogMutation) CacheCreation5mTokens() (r int, exists bool) {
	v := m.cache_creation_5m_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheCreation5mTokens returns the old "cache_creation_5m_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheCreation5mTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheCreation5mTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheCreation5mTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheCreation5mTokens: %w", err)
	}
	return oldValue.CacheCreation5mTokens, nil
}

// AddCacheCreation5mTokens adds i to the "cache_creation_5m_tokens" field.
func (m *UsageLogMutation) AddCacheCreation5mTokens(i int) {
	if m.addcache_creation_5m_tokens != nil {
		*m.addcache_creation_5m_tokens += i
	} else {
		m.addcache_creation_5m_tokens = &i
	}
}

// AddedCacheCreation5mTokens returns the value that was added to the "cache_creation_5m_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCacheCreation5mTokens() (r int, exists bool) {
	v := m.addcache_creation_5m_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheCreation5mTokens resets all changes to the "cache_creation_5m_tokens" field.
func (m *UsageLogMutation) ResetCacheCreation5mTokens() {
	m.cache_creation_5m_tokens = nil
	m.addcache_creation_5m_tokens = nil
}

// SetCacheCreation1hTokens sets the "cache_creation_1h_tokens" field.
func (m *UsageLogMutation) SetCacheCreation1hTokens(i int) {
	m.cache_creation_1h_tokens = &i
	m.addcache_creation_1h_tokens = nil
}

// CacheCreation1hTokens returns the value of the "cache_creation_1h_tokens" field in the mutation.
func (m *UsageLogMutation) CacheCreation1hTokens() (r int, exists bool) {
	v := m.cache_creation_1h_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheCreation1hTokens returns the old "cache_creation_1h_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheCreation1hTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheCreation1hTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheCreation1hTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheCreation1hTokens: %w", err)
	}
	return oldValue.CacheCreation1hTokens, nil
}

// AddCacheCreation1hTokens adds i to the "cache_creation_1h_tokens" field.
func (m *UsageLogMutation) AddCacheCreation1hTokens(i int) {
	if m.addcache_creation_1h_tokens != nil {
		*m.addcache_creation_1h_tokens += i
	} else {
		m.addcache_creation_1h_tokens = &i
	}
}

// AddedCacheCreation1hTokens returns the value that was added to the "cache_creation_1h_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCacheCreation1hTokens() (r int, exists bool) {
	v := m.addcache_creation_1h_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheCreation1hTokens resets all changes to the "cache_creation_1h_tokens" field.
func (m *UsageLogMutation) ResetCacheCreation1hTokens() {
	m.cache_creation_1h_tokens = nil
	m.addcache_creation_1h_tokens = nil
}

// SetInputCost sets the "input_cost" field.
func (m *UsageLogMutation) SetInputCost(f float64) {
	m.input_cost = &f
	m.addinput_cost = nil
}

// InputCost returns the value of the "input_cost" field in the mutation.
func (m *UsageLogMutation) InputCost() (r float64, exists bool) {
	v := m.input_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldInputCost returns the old "input_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldInputCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputCost: %w", err)
	}
	return oldValue.InputCost, nil
}

// AddInputCost adds f to the "input_cost" field.
func (m *UsageLogMutation) AddInputCost(f float64) {
	if m.addinput_cost != nil {
		*m.addinput_cost += f
	} else {
		m.addinput_cost = &f
	}
}

// AddedInputCost returns the value that was added to the "input_cost" field in this mutation.
func (m *UsageLogMutation) AddedInputCost() (r float64, exists bool) {
	v := m.addinput_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetInputCost resets all changes to the "input_cost" field.
func (m *UsageLogMutation) ResetInputCost() {
	m.input_cost = nil
	m.addinput_cost = nil
}

// SetOutputCost sets the "output_cost" field.
func (m *UsageLogMutation) SetOutputCost(f float64) {
	m.output_cost = &f
	m.addoutput_cost = nil
}

// OutputCost returns the value of the "output_cost" field in the mutation.
func (m *UsageLogMutation) OutputCost() (r float64, exists bool) {
	v := m.output_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputCost returns the old "output_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldOutputCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputCost: %w", err)
	}
	return oldValue.OutputCost, nil
}

// AddOutputCost adds f to the "output_cost" field.
func (m *UsageLogMutation) AddOutputCost(f float64) {
	if m.addoutput_cost != nil {
		*m.addoutput_cost += f
	} else {
		m.addoutput_cost = &f
	}
}

// AddedOutputCost returns the value that was added to the "output_cost" field in this mutation.
func (m *UsageLogMutation) AddedOutputCost() (r float64, exists bool) {
	v := m.addoutput_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutputCost resets all changes to the "output_cost" field.
func (m *UsageLogMutation) ResetOutputCost() {
	m.output_cost = nil
	m.addoutput_cost = nil
}

// SetCacheCreationCost sets the "cache_creation_cost" field.
func (m *UsageLogMutation) SetCacheCreationCost(f float64) {
	m.cache_creation_cost = &f
	m.addcache_creation_cost = nil
}

// CacheCreationCost returns the value of the "cache_creation_cost" field in the mutation.
func (m *UsageLogMutation) CacheCreationCost() (r float64, exists bool) {
	v := m.cache_creation_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheCreationCost returns the old "cache_creation_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheCreationCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheCreationCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheCreationCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheCreationCost: %w", err)
	}
	return oldValue.CacheCreationCost, nil
}

// AddCacheCreationCost adds f to the "cache_creation_cost" field.
func (m *UsageLogMutation) AddCacheCreationCost(f float64) {
	if m.addcache_creation_cost != nil {
		*m.addcache_creation_cost += f
	} else {
		m.addcache_creation_cost = &f
	}
}

// AddedCacheCreationCost returns the value that was added to the "cache_creation_cost" field in this mutation.
func (m *UsageLogMutation) AddedCacheCreationCost() (r float64, exists bool) {
	v := m.addcache_creation_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheCreationCost resets all changes to the "cache_creation_cost" field.
func (m *UsageLogMutation) ResetCacheCreationCost() {
	m.cache_creation_cost = nil
	m.addcache_creation_cost = nil
}

// SetCacheReadCost sets the "cache_read_cost" field.
func (m *UsageLogMutation) SetCacheReadCost(f float64) {
	m.cache_read_cost = &f
	m.addcache_read_cost = nil
}

// CacheReadCost returns the value of the "cache_read_cost" field in the mutation.
func (m *UsageLogMutation) CacheReadCost() (r float64, exists bool) {
	v := m.cache_read_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheReadCost returns the old "cache_read_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheReadCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheReadCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheReadCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheReadCost: %w", err)
	}
	return oldValue.CacheReadCost, nil
}

// AddCacheReadCost adds f to the "cache_read_cost" field.
func (m *UsageLogMutation) AddCacheReadCost(f float64) {
	if m.addcache_read_cost != nil {
		*m.addcache_read_cost += f
	} else {
		m.addcache_read_cost = &f
	}
}

// AddedCacheReadCost returns the value that was added to the "cache_read_cost" field in this mutation.
func (m *UsageLogMutation) AddedCacheReadCost() (r float64, exists bool) {
	v := m.addcache_read_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheReadCost resets all changes to the "cache_read_cost" field.
func (m *UsageLogMutation) ResetCacheReadCost() {
	m.cache_read_cost = nil
	m.addcache_read_cost = nil
}

// SetTotalCost sets the "total_cost" field.
func (m *UsageLogMutation) SetTotalCost(f float64) {
	m.total_cost = &f
	m.addtotal_cost = nil
}

// TotalCost returns the value of the "total_cost" field in the mutation.
func (m *UsageLogMutation) TotalCost() (r float64, exists bool) {
	v := m.total_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCost returns the old "total_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldTotalCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCost: %w", err)
	}
	return oldValue.TotalCost, nil
}

// AddTotalCost adds f to the "total_cost" field.
func (m *UsageLogMutation) AddTotalCost(f float64) {
	if m.addtotal_cost != nil {
		*m.addtotal_cost += f
	} else {
		m.addtotal_cost = &f
	}
}

// AddedTotalCost returns the value that was added to the "total_cost" field in this mutation.
func (m *UsageLogMutation) AddedTotalCost() (r float64, exists bool) {
	v := m.addtotal_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCost resets all changes to the "total_cost" field.
func (m *UsageLogMutation) ResetTotalCost() {
	m.total_cost = nil
	m.addtotal_cost = nil
}

// SetActualCost sets the "actual_cost" field.
func (m *UsageLogMutation) SetActualCost(f float64) {
	m.actual_cost = &f
	m.addactual_cost = nil
}

// ActualCost returns the value of the "actual_cost" field in the mutation.
func (m *UsageLogMutation) ActualCost() (r float64, exists bool) {
	v := m.actual_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldActualCost returns the old "actual_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldActualCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualCost: %w", err)
	}
	return oldValue.ActualCost, nil
}

// AddActualCost adds f to the "actual_cost" field.
func (m *UsageLogMutation) AddActualCost(f float64) {
	if m.addactual_cost != nil {
		*m.addactual_cost += f
	} else {
		m.addactual_cost = &f
	}
}

// AddedActualCost returns the value that was added to the "actual_cost" field in this mutation.
func (m *UsageLogMutation) AddedActualCost() (r float64, exists bool) {
	v := m.addactual_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetActualCost resets all changes to the "actual_cost" field.
func (m *UsageLogMutation) ResetActualCost() {
	m.actual_cost = nil
	m.addactual_cost = nil
}

// SetRateMultiplier sets the "rate_multiplier" field.
func (m *UsageLogMutation) SetRateMultiplier(f float64) {
	m.rate_multiplier = &f
	m.addrate_multiplier = nil
}

// RateMultiplier returns the value of the "rate_multiplier" field in the mutation.
func (m *UsageLogMutation) RateMultiplier() (r float64, exists bool) {
	v := m.rate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldRateMultiplier returns the old "rate_multiplier" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldRateMultiplier(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateMultiplier: %w", err)
	}
	return oldValue.RateMultiplier, nil
}

// AddRateMultiplier adds f to the "rate_multiplier" field.
func (m *UsageLogMutation) AddRateMultiplier(f float64) {
	if m.addrate_multiplier != nil {
		*m.addrate_multiplier += f
	} else {
		m.addrate_multiplier = &f
	}
}

// AddedRateMultiplier returns the value that was added to the "rate_multiplier" field in this mutation.
func (m *UsageLogMutation) AddedRateMultiplier() (r float64, exists bool) {
	v := m.addrate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// ResetRateMultiplier resets all changes to the "rate_multiplier" field.
func (m *UsageLogMutation) ResetRateMultiplier() {
	m.rate_multiplier = nil
	m.addrate_multiplier = nil
}

// SetBillingType sets the "billing_type" field.
func (m *UsageLogMutation) SetBillingType(i int8) {
	m.billing_type = &i
	m.addbilling_type = nil
}

// BillingType returns the value of the "billing_type" field in the mutation.
func (m *UsageLogMutation) BillingType() (r int8, exists bool) {
	v := m.billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingType returns the old "billing_type" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldBillingType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingType: %w", err)
	}
	return oldValue.BillingType, nil
}

// AddBillingType adds i to the "billing_type" field.
func (m *UsageLogMutation) AddBillingType(i int8) {
	if m.addbilling_type != nil {
		*m.addbilling_type += i
	} else {
		m.addbilling_type = &i
	}
}

// AddedBillingType returns the value that was added to the "billing_type" field in this mutation.
func (m *UsageLogMutation) AddedBillingType() (r int8, exists bool) {
	v := m.addbilling_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetBillingType resets all changes to the "billing_type" field.
func (m *UsageLogMutation) ResetBillingType() {
	m.billing_type = nil
	m.addbilling_type = nil
}

// SetStream sets the "stream" field.
func (m *UsageLogMutation) SetStream(b bool) {
	m.stream = &b
}

// Stream returns the value of the "stream" field in the mutation.
func (m *UsageLogMutation) Stream() (r bool, exists bool) {
	v := m.stream
	if v == nil {
		return
	}
	return *v, true
}

// OldStream returns the old "stream" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldStream(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStream is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStream requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStream: %w", err)
	}
	return oldValue.Stream, nil
}

// ResetStream resets all changes to the "stream" field.
func (m *UsageLogMutation) ResetStream() {
	m.stream = nil
}

// SetDurationMs sets the "duration_ms" field.
func (m *UsageLogMutation) SetDurationMs(i int) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *UsageLogMutation) DurationMs() (r int, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldDurationMs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *UsageLogMutation) AddDurationMs(i int) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *UsageLogMutation) AddedDurationMs() (r int, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *UsageLogMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[usagelog.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *UsageLogMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *UsageLogMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, usagelog.FieldDurationMs)
}

// SetFirstTokenMs sets the "first_token_ms" field.
func (m *UsageLogMutation) SetFirstTokenMs(i int) {
	m.first_token_ms = &i
	m.addfirst_token_ms = nil
}

// FirstTokenMs returns the value of the "first_token_ms" field in the mutation.
func (m *UsageLogMutation) FirstTokenMs() (r int, exists bool) {
	v := m.first_token_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstTokenMs returns the old "first_token_ms" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldFirstTokenMs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstTokenMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstTokenMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstTokenMs: %w", err)
	}
	return oldValue.FirstTokenMs, nil
}

// AddFirstTokenMs adds i to the "first_token_ms" field.
func (m *UsageLogMutation) AddFirstTokenMs(i int) {
	if m.addfirst_token_ms != nil {
		*m.addfirst_token_ms += i
	} else {
		m.addfirst_token_ms = &i
	}
}

// AddedFirstTokenMs returns the value that was added to the "first_token_ms" field in this mutation.
func (m *UsageLogMutation) AddedFirstTokenMs() (r int, exists bool) {
	v := m.addfirst_token_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstTokenMs clears the value of the "first_token_ms" field.
func (m *UsageLogMutation) ClearFirstTokenMs() {
	m.first_token_ms = nil
	m.addfirst_token_ms = nil
	m.clearedFields[usagelog.FieldFirstTokenMs] = struct{}{}
}

// FirstTokenMsCleared returns if the "first_token_ms" field was cleared in this mutation.
func (m *UsageLogMutation) FirstTokenMsCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldFirstTokenMs]
	return ok
}

// ResetFirstTokenMs resets all changes to the "first_token_ms" field.
func (m *UsageLogMutation) ResetFirstTokenMs() {
	m.first_token_ms = nil
	m.addfirst_token_ms = nil
	delete(m.clearedFields, usagelog.FieldFirstTokenMs)
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UsageLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usagelog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UsageLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UsageLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearAPIKey clears the "api_key" edge to the APIKey entity.
func (m *UsageLogMutation) ClearAPIKey() {
	m.clearedapi_key = true
	m.clearedFields[usagelog.FieldAPIKeyID] = struct{}{}
}

// APIKeyCleared reports if the "api_key" edge to the APIKey entity was cleared.
func (m *UsageLogMutation) APIKeyCleared() bool {
	return m.clearedapi_key
}

// APIKeyIDs returns the "api_key" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APIKeyID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) APIKeyIDs() (ids []int64) {
	if id := m.api_key; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPIKey resets all changes to the "api_key" edge.
func (m *UsageLogMutation) ResetAPIKey() {
	m.api_key = nil
	m.clearedapi_key = false
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *UsageLogMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[usagelog.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *UsageLogMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) AccountIDs() (ids []int64) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *UsageLogMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UsageLogMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[usagelog.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UsageLogMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UsageLogMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// ClearSubscription clears the "subscription" edge to the UserSubscription entity.
func (m *UsageLogMutation) ClearSubscription() {
	m.clearedsubscription = true
	m.clearedFields[usagelog.FieldSubscriptionID] = struct{}{}
}

// SubscriptionCleared reports if the "subscription" edge to the UserSubscription entity was cleared.
func (m *UsageLogMutation) SubscriptionCleared() bool {
	return m.SubscriptionIDCleared() || m.clearedsubscription
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) SubscriptionIDs() (ids []int64) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *UsageLogMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// Where appends a list predicates to the UsageLogMutation builder.
func (m *UsageLogMutation) Where(ps ...predicate.UsageLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageLog).
func (m *UsageLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageLogMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.user != nil {
		fields = append(fields, usagelog.FieldUserID)
	}
	if m.api_key != nil {
		fields = append(fields, usagelog.FieldAPIKeyID)
	}
	if m.account != nil {
		fields = append(fields, usagelog.FieldAccountID)
	}
	if m.request_id != nil {
		fields = append(fields, usagelog.FieldRequestID)
	}
	if m.model != nil {
		fields = append(fields, usagelog.FieldModel)
	}
	if m.group != nil {
		fields = append(fields, usagelog.FieldGroupID)
	}
	if m.subscription != nil {
		fields = append(fields, usagelog.FieldSubscriptionID)
	}
	if m.input_tokens != nil {
		fields = append(fields, usagelog.FieldInputTokens)
	}
	if m.output_tokens != nil {
		fields = append(fields, usagelog.FieldOutputTokens)
	}
	if m.cache_creation_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreationTokens)
	}
	if m.cache_read_tokens != nil {
		fields = append(fields, usagelog.FieldCacheReadTokens)
	}
	if m.cache_creation_5m_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreation5mTokens)
	}
	if m.cache_creation_1h_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreation1hTokens)
	}
	if m.input_cost != nil {
		fields = append(fields, usagelog.FieldInputCost)
	}
	if m.output_cost != nil {
		fields = append(fields, usagelog.FieldOutputCost)
	}
	if m.cache_creation_cost != nil {
		fields = append(fields, usagelog.FieldCacheCreationCost)
	}
	if m.cache_read_cost != nil {
		fields = append(fields, usagelog.FieldCacheReadCost)
	}
	if m.total_cost != nil {
		fields = append(fields, usagelog.FieldTotalCost)
	}
	if m.actual_cost != nil {
		fields = append(fields, usagelog.FieldActualCost)
	}
	if m.rate_multiplier != nil {
		fields = append(fields, usagelog.FieldRateMultiplier)
	}
	if m.billing_type != nil {
		fields = append(fields, usagelog.FieldBillingType)
	}
	if m.stream != nil {
		fields = append(fields, usagelog.FieldStream)
	}
	if m.duration_ms != nil {
		fields = append(fields, usagelog.FieldDurationMs)
	}
	if m.first_token_ms != nil {
		fields = append(fields, usagelog.FieldFirstTokenMs)
	}
	if m.created_at != nil {
		fields = append(fields, usagelog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldUserID:
		return m.UserID()
	case usagelog.FieldAPIKeyID:
		return m.APIKeyID()
	case usagelog.FieldAccountID:
		return m.AccountID()
	case usagelog.FieldRequestID:
		return m.RequestID()
	case usagelog.FieldModel:
		return m.Model()
	case usagelog.FieldGroupID:
		return m.GroupID()
	case usagelog.FieldSubscriptionID:
		return m.SubscriptionID()
	case usagelog.FieldInputTokens:
		return m.InputTokens()
	case usagelog.FieldOutputTokens:
		return m.OutputTokens()
	case usagelog.FieldCacheCreationTokens:
		return m.CacheCreationTokens()
	case usagelog.FieldCacheReadTokens:
		return m.CacheReadTokens()
	case usagelog.FieldCacheCreation5mTokens:
		return m.CacheCreation5mTokens()
	case usagelog.FieldCacheCreation1hTokens:
		return m.CacheCreation1hTokens()
	case usagelog.FieldInputCost:
		return m.InputCost()
	case usagelog.FieldOutputCost:
		return m.OutputCost()
	case usagelog.FieldCacheCreationCost:
		return m.CacheCreationCost()
	case usagelog.FieldCacheReadCost:
		return m.CacheReadCost()
	case usagelog.FieldTotalCost:
		return m.TotalCost()
	case usagelog.FieldActualCost:
		return m.ActualCost()
	case usagelog.FieldRateMultiplier:
		return m.RateMultiplier()
	case usagelog.FieldBillingType:
		return m.BillingType()
	case usagelog.FieldStream:
		return m.Stream()
	case usagelog.FieldDurationMs:
		return m.DurationMs()
	case usagelog.FieldFirstTokenMs:
		return m.FirstTokenMs()
	case usagelog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagelog.FieldUserID:
		return m.OldUserID(ctx)
	case usagelog.FieldAPIKeyID:
		return m.OldAPIKeyID(ctx)
	case usagelog.FieldAccountID:
		return m.OldAccountID(ctx)
	case usagelog.FieldRequestID:
		return m.OldRequestID(ctx)
	case usagelog.FieldModel:
		return m.OldModel(ctx)
	case usagelog.FieldGroupID:
		return m.OldGroupID(ctx)
	case usagelog.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case usagelog.FieldInputTokens:
		return m.OldInputTokens(ctx)
	case usagelog.FieldOutputTokens:
		return m.OldOutputTokens(ctx)
	case usagelog.FieldCacheCreationTokens:
		return m.OldCacheCreationTokens(ctx)
	case usagelog.FieldCacheReadTokens:
		return m.OldCacheReadTokens(ctx)
	case usagelog.FieldCacheCreation5mTokens:
		return m.OldCacheCreation5mTokens(ctx)
	case usagelog.FieldCacheCreation1hTokens:
		return m.OldCacheCreation1hTokens(ctx)
	case usagelog.FieldInputCost:
		return m.OldInputCost(ctx)
	case usagelog.FieldOutputCost:
		return m.OldOutputCost(ctx)
	case usagelog.FieldCacheCreationCost:
		return m.OldCacheCreationCost(ctx)
	case usagelog.FieldCacheReadCost:
		return m.OldCacheReadCost(ctx)
	case usagelog.FieldTotalCost:
		return m.OldTotalCost(ctx)
	case usagelog.FieldActualCost:
		return m.OldActualCost(ctx)
	case usagelog.FieldRateMultiplier:
		return m.OldRateMultiplier(ctx)
	case usagelog.FieldBillingType:
		return m.OldBillingType(ctx)
	case usagelog.FieldStream:
		return m.OldStream(ctx)
	case usagelog.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case usagelog.FieldFirstTokenMs:
		return m.OldFirstTokenMs(ctx)
	case usagelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UsageLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usagelog.FieldAPIKeyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKeyID(v)
		return nil
	case usagelog.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case usagelog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case usagelog.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case usagelog.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case usagelog.FieldSubscriptionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case usagelog.FieldInputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputTokens(v)
		return nil
	case usagelog.FieldOutputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputTokens(v)
		return nil
	case usagelog.FieldCacheCreationTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheCreationTokens(v)
		return nil
	case usagelog.FieldCacheReadTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheReadTokens(v)
		return nil
	case usagelog.FieldCacheCreation5mTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheCreation5mTokens(v)
		return nil
	case usagelog.FieldCacheCreation1hTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheCreation1hTokens(v)
		return nil
	case usagelog.FieldInputCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputCost(v)
		return nil
	case usagelog.FieldOutputCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputCost(v)
		return nil
	case usagelog.FieldCacheCreationCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheCreationCost(v)
		return nil
	case usagelog.FieldCacheReadCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheReadCost(v)
		return nil
	case usagelog.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCost(v)
		return nil
	case usagelog.FieldActualCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualCost(v)
		return nil
	case usagelog.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateMultiplier(v)
		return nil
	case usagelog.FieldBillingType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingType(v)
		return nil
	case usagelog.FieldStream:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStream(v)
		return nil
	case usagelog.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case usagelog.FieldFirstTokenMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstTokenMs(v)
		return nil
	case usagelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageLogMutation) AddedFields() []string {
	var fields []string
	if m.addinput_tokens != nil {
		fields = append(fields, usagelog.FieldInputTokens)
	}
	if m.addoutput_tokens != nil {
		fields = append(fields, usagelog.FieldOutputTokens)
	}
	if m.addcache_creation_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreationTokens)
	}
	if m.addcache_read_tokens != nil {
		fields = append(fields, usagelog.FieldCacheReadTokens)
	}
	if m.addcache_creation_5m_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreation5mTokens)
	}
	if m.addcache_creation_1h_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreation1hTokens)
	}
	if m.addinput_cost != nil {
		fields = append(fields, usagelog.FieldInputCost)
	}
	if m.addoutput_cost != nil {
		fields = append(fields, usagelog.FieldOutputCost)
	}
	if m.addcache_creation_cost != nil {
		fields = append(fields, usagelog.FieldCacheCreationCost)
	}
	if m.addcache_read_cost != nil {
		fields = append(fields, usagelog.FieldCacheReadCost)
	}
	if m.addtotal_cost != nil {
		fields = append(fields, usagelog.FieldTotalCost)
	}
	if m.addactual_cost != nil {
		fields = append(fields, usagelog.FieldActualCost)
	}
	if m.addrate_multiplier != nil {
		fields = append(fields, usagelog.FieldRateMultiplier)
	}
	if m.addbilling_type != nil {
		fields = append(fields, usagelog.FieldBillingType)
	}
	if m.addduration_ms != nil {
		fields = append(fields, usagelog.FieldDurationMs)
	}
	if m.addfirst_token_ms != nil {
		fields = append(fields, usagelog.FieldFirstTokenMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldInputTokens:
		return m.AddedInputTokens()
	case usagelog.FieldOutputTokens:
		return m.AddedOutputTokens()
	case usagelog.FieldCacheCreationTokens:
		return m.AddedCacheCreationTokens()
	case usagelog.FieldCacheReadTokens:
		return m.AddedCacheReadTokens()
	case usagelog.FieldCacheCreation5mTokens:
		return m.AddedCacheCreation5mTokens()
	case usagelog.FieldCacheCreation1hTokens:
		return m.AddedCacheCreation1hTokens()
	case usagelog.FieldInputCost:
		return m.AddedInputCost()
	case usagelog.FieldOutputCost:
		return m.AddedOutputCost()
	case usagelog.FieldCacheCreationCost:
		return m.AddedCacheCreationCost()
	case usagelog.FieldCacheReadCost:
		return m.AddedCacheReadCost()
	case usagelog.FieldTotalCost:
		return m.AddedTotalCost()
	case usagelog.FieldActualCost:
		return m.AddedActualCost()
	case usagelog.FieldRateMultiplier:
		return m.AddedRateMultiplier()
	case usagelog.FieldBillingType:
		return m.AddedBillingType()
	case usagelog.FieldDurationMs:
		return m.AddedDurationMs()
	case usagelog.FieldFirstTokenMs:
		return m.AddedFirstTokenMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldInputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputTokens(v)
		return nil
	case usagelog.FieldOutputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputTokens(v)
		return nil
	case usagelog.FieldCacheCreationTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheCreationTokens(v)
		return nil
	case usagelog.FieldCacheReadTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheReadTokens(v)
		return nil
	case usagelog.FieldCacheCreation5mTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheCreation5mTokens(v)
		return nil
	case usagelog.FieldCacheCreation1hTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheCreation1hTokens(v)
		return nil
	case usagelog.FieldInputCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputCost(v)
		return nil
	case usagelog.FieldOutputCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputCost(v)
		return nil
	case usagelog.FieldCacheCreationCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheCreationCost(v)
		return nil
	case usagelog.FieldCacheReadCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheReadCost(v)
		return nil
	case usagelog.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCost(v)
		return nil
	case usagelog.FieldActualCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActualCost(v)
		return nil
	case usagelog.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRateMultiplier(v)
		return nil
	case usagelog.FieldBillingType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBillingType(v)
		return nil
	case usagelog.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	case usagelog.FieldFirstTokenMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstTokenMs(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagelog.FieldGroupID) {
		fields = append(fields, usagelog.FieldGroupID)
	}
	if m.FieldCleared(usagelog.FieldSubscriptionID) {
		fields = append(fields, usagelog.FieldSubscriptionID)
	}
	if m.FieldCleared(usagelog.FieldDurationMs) {
		fields = append(fields, usagelog.FieldDurationMs)
	}
	if m.FieldCleared(usagelog.FieldFirstTokenMs) {
		fields = append(fields, usagelog.FieldFirstTokenMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageLogMutation) ClearField(name string) error {
	switch name {
	case usagelog.FieldGroupID:
		m.ClearGroupID()
		return nil
	case usagelog.FieldSubscriptionID:
		m.ClearSubscriptionID()
		return nil
	case usagelog.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	case usagelog.FieldFirstTokenMs:
		m.ClearFirstTokenMs()
		return nil
	}
	return fmt.Errorf("unknown UsageLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageLogMutation) ResetField(name string) error {
	switch name {
	case usagelog.FieldUserID:
		m.ResetUserID()
		return nil
	case usagelog.FieldAPIKeyID:
		m.ResetAPIKeyID()
		return nil
	case usagelog.FieldAccountID:
		m.ResetAccountID()
		return nil
	case usagelog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case usagelog.FieldModel:
		m.ResetModel()
		return nil
	case usagelog.FieldGroupID:
		m.ResetGroupID()
		return nil
	case usagelog.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case usagelog.FieldInputTokens:
		m.ResetInputTokens()
		return nil
	case usagelog.FieldOutputTokens:
		m.ResetOutputTokens()
		return nil
	case usagelog.FieldCacheCreationTokens:
		m.ResetCacheCreationTokens()
		return nil
	case usagelog.FieldCacheReadTokens:
		m.ResetCacheReadTokens()
		return nil
	case usagelog.FieldCacheCreation5mTokens:
		m.ResetCacheCreation5mTokens()
		return nil
	case usagelog.FieldCacheCreation1hTokens:
		m.ResetCacheCreation1hTokens()
		return nil
	case usagelog.FieldInputCost:
		m.ResetInputCost()
		return nil
	case usagelog.FieldOutputCost:
		m.ResetOutputCost()
		return nil
	case usagelog.FieldCacheCreationCost:
		m.ResetCacheCreationCost()
		return nil
	case usagelog.FieldCacheReadCost:
		m.ResetCacheReadCost()
		return nil
	case usagelog.FieldTotalCost:
		m.ResetTotalCost()
		return nil
	case usagelog.FieldActualCost:
		m.ResetActualCost()
		return nil
	case usagelog.FieldRateMultiplier:
		m.ResetRateMultiplier()
		return nil
	case usagelog.FieldBillingType:
		m.ResetBillingType()
		return nil
	case usagelog.FieldStream:
		m.ResetStream()
		return nil
	case usagelog.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case usagelog.FieldFirstTokenMs:
		m.ResetFirstTokenMs()
		return nil
	case usagelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, usagelog.EdgeUser)
	}
	if m.api_key != nil {
		edges = append(edges, usagelog.EdgeAPIKey)
	}
	if m.account != nil {
		edges = append(edges, usagelog.EdgeAccount)
	}
	if m.group != nil {
		edges = append(edges, usagelog.EdgeGroup)
	}
	if m.subscription != nil {
		edges = append(edges, usagelog.EdgeSubscription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagelog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeAPIKey:
		if id := m.api_key; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, usagelog.EdgeUser)
	}
	if m.clearedapi_key {
		edges = append(edges, usagelog.EdgeAPIKey)
	}
	if m.clearedaccount {
		edges = append(edges, usagelog.EdgeAccount)
	}
	if m.clearedgroup {
		edges = append(edges, usagelog.EdgeGroup)
	}
	if m.clearedsubscription {
		edges = append(edges, usagelog.EdgeSubscription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageLogMutation) EdgeCleared(name string) bool {
	switch name {
	case usagelog.EdgeUser:
		return m.cleareduser
	case usagelog.EdgeAPIKey:
		return m.clearedapi_key
	case usagelog.EdgeAccount:
		return m.clearedaccount
	case usagelog.EdgeGroup:
		return m.clearedgroup
	case usagelog.EdgeSubscription:
		return m.clearedsubscription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageLogMutation) ClearEdge(name string) error {
	switch name {
	case usagelog.EdgeUser:
		m.ClearUser()
		return nil
	case usagelog.EdgeAPIKey:
		m.ClearAPIKey()
		return nil
	case usagelog.EdgeAccount:
		m.ClearAccount()
		return nil
	case usagelog.EdgeGroup:
		m.ClearGroup()
		return nil
	case usagelog.EdgeSubscription:
		m.ClearSubscription()
		return nil
	}
	return fmt.Errorf("unknown UsageLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageLogMutation) ResetEdge(name string) error {
	switch name {
	case usagelog.EdgeUser:
		m.ResetUser()
		return nil
	case usagelog.EdgeAPIKey:
		m.ResetAPIKey()
		return nil
	case usagelog.EdgeAccount:
		m.ResetAccount()
		return nil
	case usagelog.EdgeGroup:
		m.ResetGroup()
		return nil
	case usagelog.EdgeSubscription:
		m.ResetSubscription()
		return nil
	}
	return fmt.Errorf("unknown UsageLog edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	email                         *string
	password_hash                 *string
	role                          *string
	balance                       *float64
	addbalance                    *float64
	concurrency                   *int
	addconcurrency                *int
	status                        *string
	username                      *string
	notes                         *string
	clearedFields                 map[string]struct{}
	api_keys                      map[int64]struct{}
	removedapi_keys               map[int64]struct{}
	clearedapi_keys               bool
	redeem_codes                  map[int64]struct{}
	removedredeem_codes           map[int64]struct{}
	clearedredeem_codes           bool
	subscriptions                 map[int64]struct{}
	removedsubscriptions          map[int64]struct{}
	clearedsubscriptions          bool
	assigned_subscriptions        map[int64]struct{}
	removedassigned_subscriptions map[int64]struct{}
	clearedassigned_subscriptions bool
	allowed_groups                map[int64]struct{}
	removedallowed_groups         map[int64]struct{}
	clearedallowed_groups         bool
	usage_logs                    map[int64]struct{}
	removedusage_logs             map[int64]struct{}
	clearedusage_logs             bool
	attribute_values              map[int64]struct{}
	removedattribute_values       map[int64]struct{}
	clearedattribute_values       bool
	done                          bool
	oldValue                      func(context.Context) (*User, error)
	predicates                    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetBalance sets the "balance" field.
func (m *UserMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *UserMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *UserMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *UserMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *UserMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetConcurrency sets the "concurrency" field.
func (m *UserMutation) SetConcurrency(i int) {
	m.concurrency = &i
	m.addconcurrency = nil
}

// Concurrency returns the value of the "concurrency" field in the mutation.
func (m *UserMutation) Concurrency() (r int, exists bool) {
	v := m.concurrency
	if v == nil {
		return
	}
	return *v, true
}

// OldConcurrency returns the old "concurrency" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldConcurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcurrency: %w", err)
	}
	return oldValue.Concurrency, nil
}

// AddConcurrency adds i to the "concurrency" field.
func (m *UserMutation) AddConcurrency(i int) {
	if m.addconcurrency != nil {
		*m.addconcurrency += i
	} else {
		m.addconcurrency = &i
	}
}

// AddedConcurrency returns the value that was added to the "concurrency" field in this mutation.
func (m *UserMutation) AddedConcurrency() (r int, exists bool) {
	v := m.addconcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ResetConcurrency resets all changes to the "concurrency" field.
func (m *UserMutation) ResetConcurrency() {
	m.concurrency = nil
	m.addconcurrency = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetNotes sets the "notes" field.
func (m *UserMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *UserMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *UserMutation) ResetNotes() {
	m.notes = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...int64) {
	if m.api_keys == nil {
		m.api_keys = make(map[int64]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...int64) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []int64) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []int64) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRedeemCodeIDs adds the "redeem_codes" edge to the RedeemCode entity by ids.
func (m *UserMutation) AddRedeemCodeIDs(ids ...int64) {
	if m.redeem_codes == nil {
		m.redeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		m.redeem_codes[ids[i]] = struct{}{}
	}
}

// ClearRedeemCodes clears the "redeem_codes" edge to the RedeemCode entity.
func (m *UserMutation) ClearRedeemCodes() {
	m.clearedredeem_codes = true
}

// RedeemCodesCleared reports if the "redeem_codes" edge to the RedeemCode entity was cleared.
func (m *UserMutation) RedeemCodesCleared() bool {
	return m.clearedredeem_codes
}

// RemoveRedeemCodeIDs removes the "redeem_codes" edge to the RedeemCode entity by IDs.
func (m *UserMutation) RemoveRedeemCodeIDs(ids ...int64) {
	if m.removedredeem_codes == nil {
		m.removedredeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.redeem_codes, ids[i])
		m.removedredeem_codes[ids[i]] = struct{}{}
	}
}

// RemovedRedeemCodes returns the removed IDs of the "redeem_codes" edge to the RedeemCode entity.
func (m *UserMutation) RemovedRedeemCodesIDs() (ids []int64) {
	for id := range m.removedredeem_codes {
		ids = append(ids, id)
	}
	return
}

// RedeemCodesIDs returns the "redeem_codes" edge IDs in the mutation.
func (m *UserMutation) RedeemCodesIDs() (ids []int64) {
	for id := range m.redeem_codes {
		ids = append(ids, id)
	}
	return
}

// ResetRedeemCodes resets all changes to the "redeem_codes" edge.
func (m *UserMutation) ResetRedeemCodes() {
	m.redeem_codes = nil
	m.clearedredeem_codes = false
	m.removedredeem_codes = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the UserSubscription entity by ids.
func (m *UserMutation) AddSubscriptionIDs(ids ...int64) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the UserSubscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the UserSubscription entity by IDs.
func (m *UserMutation) RemoveSubscriptionIDs(ids ...int64) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) RemovedSubscriptionsIDs() (ids []int64) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *UserMutation) SubscriptionsIDs() (ids []int64) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddAssignedSubscriptionIDs adds the "assigned_subscriptions" edge to the UserSubscription entity by ids.
func (m *UserMutation) AddAssignedSubscriptionIDs(ids ...int64) {
	if m.assigned_subscriptions == nil {
		m.assigned_subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		m.assigned_subscriptions[ids[i]] = struct{}{}
	}
}

// ClearAssignedSubscriptions clears the "assigned_subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) ClearAssignedSubscriptions() {
	m.clearedassigned_subscriptions = true
}

// AssignedSubscriptionsCleared reports if the "assigned_subscriptions" edge to the UserSubscription entity was cleared.
func (m *UserMutation) AssignedSubscriptionsCleared() bool {
	return m.clearedassigned_subscriptions
}

// RemoveAssignedSubscriptionIDs removes the "assigned_subscriptions" edge to the UserSubscription entity by IDs.
func (m *UserMutation) RemoveAssignedSubscriptionIDs(ids ...int64) {
	if m.removedassigned_subscriptions == nil {
		m.removedassigned_subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.assigned_subscriptions, ids[i])
		m.removedassigned_subscriptions[ids[i]] = struct{}{}
	}
}

// RemovedAssignedSubscriptions returns the removed IDs of the "assigned_subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) RemovedAssignedSubscriptionsIDs() (ids []int64) {
	for id := range m.removedassigned_subscriptions {
		ids = append(ids, id)
	}
	return
}

// AssignedSubscriptionsIDs returns the "assigned_subscriptions" edge IDs in the mutation.
func (m *UserMutation) AssignedSubscriptionsIDs() (ids []int64) {
	for id := range m.assigned_subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedSubscriptions resets all changes to the "assigned_subscriptions" edge.
func (m *UserMutation) ResetAssignedSubscriptions() {
	m.assigned_subscriptions = nil
	m.clearedassigned_subscriptions = false
	m.removedassigned_subscriptions = nil
}

// AddAllowedGroupIDs adds the "allowed_groups" edge to the Group entity by ids.
func (m *UserMutation) AddAllowedGroupIDs(ids ...int64) {
	if m.allowed_groups == nil {
		m.allowed_groups = make(map[int64]struct{})
	}
	for i := range ids {
		m.allowed_groups[ids[i]] = struct{}{}
	}
}

// ClearAllowedGroups clears the "allowed_groups" edge to the Group entity.
func (m *UserMutation) ClearAllowedGroups() {
	m.clearedallowed_groups = true
}

// AllowedGroupsCleared reports if the "allowed_groups" edge to the Group entity was cleared.
func (m *UserMutation) AllowedGroupsCleared() bool {
	return m.clearedallowed_groups
}

// RemoveAllowedGroupIDs removes the "allowed_groups" edge to the Group entity by IDs.
func (m *UserMutation) RemoveAllowedGroupIDs(ids ...int64) {
	if m.removedallowed_groups == nil {
		m.removedallowed_groups = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allowed_groups, ids[i])
		m.removedallowed_groups[ids[i]] = struct{}{}
	}
}

// RemovedAllowedGroups returns the removed IDs of the "allowed_groups" edge to the Group entity.
func (m *UserMutation) RemovedAllowedGroupsIDs() (ids []int64) {
	for id := range m.removedallowed_groups {
		ids = append(ids, id)
	}
	return
}

// AllowedGroupsIDs returns the "allowed_groups" edge IDs in the mutation.
func (m *UserMutation) AllowedGroupsIDs() (ids []int64) {
	for id := range m.allowed_groups {
		ids = append(ids, id)
	}
	return
}

// ResetAllowedGroups resets all changes to the "allowed_groups" edge.
func (m *UserMutation) ResetAllowedGroups() {
	m.allowed_groups = nil
	m.clearedallowed_groups = false
	m.removedallowed_groups = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *UserMutation) AddUsageLogIDs(ids ...int64) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *UserMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *UserMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *UserMutation) RemoveUsageLogIDs(ids ...int64) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *UserMutation) RemovedUsageLogsIDs() (ids []int64) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *UserMutation) UsageLogsIDs() (ids []int64) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *UserMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddAttributeValueIDs adds the "attribute_values" edge to the UserAttributeValue entity by ids.
func (m *UserMutation) AddAttributeValueIDs(ids ...int64) {
	if m.attribute_values == nil {
		m.attribute_values = make(map[int64]struct{})
	}
	for i := range ids {
		m.attribute_values[ids[i]] = struct{}{}
	}
}

// ClearAttributeValues clears the "attribute_values" edge to the UserAttributeValue entity.
func (m *UserMutation) ClearAttributeValues() {
	m.clearedattribute_values = true
}

// AttributeValuesCleared reports if the "attribute_values" edge to the UserAttributeValue entity was cleared.
func (m *UserMutation) AttributeValuesCleared() bool {
	return m.clearedattribute_values
}

// RemoveAttributeValueIDs removes the "attribute_values" edge to the UserAttributeValue entity by IDs.
func (m *UserMutation) RemoveAttributeValueIDs(ids ...int64) {
	if m.removedattribute_values == nil {
		m.removedattribute_values = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.attribute_values, ids[i])
		m.removedattribute_values[ids[i]] = struct{}{}
	}
}

// RemovedAttributeValues returns the removed IDs of the "attribute_values" edge to the UserAttributeValue entity.
func (m *UserMutation) RemovedAttributeValuesIDs() (ids []int64) {
	for id := range m.removedattribute_values {
		ids = append(ids, id)
	}
	return
}

// AttributeValuesIDs returns the "attribute_values" edge IDs in the mutation.
func (m *UserMutation) AttributeValuesIDs() (ids []int64) {
	for id := range m.attribute_values {
		ids = append(ids, id)
	}
	return
}

// ResetAttributeValues resets all changes to the "attribute_values" edge.
func (m *UserMutation) ResetAttributeValues() {
	m.attribute_values = nil
	m.clearedattribute_values = false
	m.removedattribute_values = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.balance != nil {
		fields = append(fields, user.FieldBalance)
	}
	if m.concurrency != nil {
		fields = append(fields, user.FieldConcurrency)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.notes != nil {
		fields = append(fields, user.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldRole:
		return m.Role()
	case user.FieldBalance:
		return m.Balance()
	case user.FieldConcurrency:
		return m.Concurrency()
	case user.FieldStatus:
		return m.Status()
	case user.FieldUsername:
		return m.Username()
	case user.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldBalance:
		return m.OldBalance(ctx)
	case user.FieldConcurrency:
		return m.OldConcurrency(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case user.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcurrency(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, user.FieldBalance)
	}
	if m.addconcurrency != nil {
		fields = append(fields, user.FieldConcurrency)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldBalance:
		return m.AddedBalance()
	case user.FieldConcurrency:
		return m.AddedConcurrency()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case user.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConcurrency(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldBalance:
		m.ResetBalance()
		return nil
	case user.FieldConcurrency:
		m.ResetConcurrency()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.redeem_codes != nil {
		edges = append(edges, user.EdgeRedeemCodes)
	}
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.assigned_subscriptions != nil {
		edges = append(edges, user.EdgeAssignedSubscriptions)
	}
	if m.allowed_groups != nil {
		edges = append(edges, user.EdgeAllowedGroups)
	}
	if m.usage_logs != nil {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.attribute_values != nil {
		edges = append(edges, user.EdgeAttributeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.redeem_codes))
		for id := range m.redeem_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedSubscriptions:
		ids := make([]ent.Value, 0, len(m.assigned_subscriptions))
		for id := range m.assigned_subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAllowedGroups:
		ids := make([]ent.Value, 0, len(m.allowed_groups))
		for id := range m.allowed_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAttributeValues:
		ids := make([]ent.Value, 0, len(m.attribute_values))
		for id := range m.attribute_values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedredeem_codes != nil {
		edges = append(edges, user.EdgeRedeemCodes)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.removedassigned_subscriptions != nil {
		edges = append(edges, user.EdgeAssignedSubscriptions)
	}
	if m.removedallowed_groups != nil {
		edges = append(edges, user.EdgeAllowedGroups)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.removedattribute_values != nil {
		edges = append(edges, user.EdgeAttributeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.removedredeem_codes))
		for id := range m.removedredeem_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedassigned_subscriptions))
		for id := range m.removedassigned_subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAllowedGroups:
		ids := make([]ent.Value, 0, len(m.removedallowed_groups))
		for id := range m.removedallowed_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAttributeValues:
		ids := make([]ent.Value, 0, len(m.removedattribute_values))
		for id := range m.removedattribute_values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedredeem_codes {
		edges = append(edges, user.EdgeRedeemCodes)
	}
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.clearedassigned_subscriptions {
		edges = append(edges, user.EdgeAssignedSubscriptions)
	}
	if m.clearedallowed_groups {
		edges = append(edges, user.EdgeAllowedGroups)
	}
	if m.clearedusage_logs {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.clearedattribute_values {
		edges = append(edges, user.EdgeAttributeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeRedeemCodes:
		return m.clearedredeem_codes
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	case user.EdgeAssignedSubscriptions:
		return m.clearedassigned_subscriptions
	case user.EdgeAllowedGroups:
		return m.clearedallowed_groups
	case user.EdgeUsageLogs:
		return m.clearedusage_logs
	case user.EdgeAttributeValues:
		return m.clearedattribute_values
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeRedeemCodes:
		m.ResetRedeemCodes()
		return nil
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case user.EdgeAssignedSubscriptions:
		m.ResetAssignedSubscriptions()
		return nil
	case user.EdgeAllowedGroups:
		m.ResetAllowedGroups()
		return nil
	case user.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case user.EdgeAttributeValues:
		m.ResetAttributeValues()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAllowedGroupMutation represents an operation that mutates the UserAllowedGroup nodes in the graph.
type UserAllowedGroupMutation struct {
	config
	op            Op
	typ           string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	group         *int64
	clearedgroup  bool
	done          bool
	oldValue      func(context.Context) (*UserAllowedGroup, error)
	predicates    []predicate.UserAllowedGroup
}

var _ ent.Mutation = (*UserAllowedGroupMutation)(nil)

// userallowedgroupOption allows management of the mutation configuration using functional options.
type userallowedgroupOption func(*UserAllowedGroupMutation)

// newUserAllowedGroupMutation creates new mutation for the UserAllowedGroup entity.
func newUserAllowedGroupMutation(c config, op Op, opts ...userallowedgroupOption) *UserAllowedGroupMutation {
	m := &UserAllowedGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAllowedGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAllowedGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAllowedGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserID sets the "user_id" field.
func (m *UserAllowedGroupMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAllowedGroupMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAllowedGroupMutation) ResetUserID() {
	m.user = nil
}

// SetGroupID sets the "group_id" field.
func (m *UserAllowedGroupMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *UserAllowedGroupMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *UserAllowedGroupMutation) ResetGroupID() {
	m.group = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAllowedGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAllowedGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAllowedGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAllowedGroupMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userallowedgroup.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAllowedGroupMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAllowedGroupMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAllowedGroupMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UserAllowedGroupMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[userallowedgroup.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UserAllowedGroupMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserAllowedGroupMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserAllowedGroupMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the UserAllowedGroupMutation builder.
func (m *UserAllowedGroupMutation) Where(ps ...predicate.UserAllowedGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAllowedGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAllowedGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAllowedGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAllowedGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAllowedGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAllowedGroup).
func (m *UserAllowedGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAllowedGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, userallowedgroup.FieldUserID)
	}
	if m.group != nil {
		fields = append(fields, userallowedgroup.FieldGroupID)
	}
	if m.created_at != nil {
		fields = append(fields, userallowedgroup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAllowedGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userallowedgroup.FieldUserID:
		return m.UserID()
	case userallowedgroup.FieldGroupID:
		return m.GroupID()
	case userallowedgroup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAllowedGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserAllowedGroup does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAllowedGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userallowedgroup.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userallowedgroup.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case userallowedgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAllowedGroupMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAllowedGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAllowedGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAllowedGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAllowedGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAllowedGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAllowedGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserAllowedGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAllowedGroupMutation) ResetField(name string) error {
	switch name {
	case userallowedgroup.FieldUserID:
		m.ResetUserID()
		return nil
	case userallowedgroup.FieldGroupID:
		m.ResetGroupID()
		return nil
	case userallowedgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAllowedGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userallowedgroup.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, userallowedgroup.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAllowedGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userallowedgroup.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userallowedgroup.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAllowedGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAllowedGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAllowedGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userallowedgroup.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, userallowedgroup.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAllowedGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case userallowedgroup.EdgeUser:
		return m.cleareduser
	case userallowedgroup.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAllowedGroupMutation) ClearEdge(name string) error {
	switch name {
	case userallowedgroup.EdgeUser:
		m.ClearUser()
		return nil
	case userallowedgroup.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAllowedGroupMutation) ResetEdge(name string) error {
	switch name {
	case userallowedgroup.EdgeUser:
		m.ResetUser()
		return nil
	case userallowedgroup.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup edge %s", name)
}

// UserAttributeDefinitionMutation represents an operation that mutates the UserAttributeDefinition nodes in the graph.
type UserAttributeDefinitionMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	key              *string
	name             *string
	description      *string
	_type            *string
	options          *[]map[string]interface{}
	appendoptions    []map[string]interface{}
	required         *bool
	validation       *map[string]interface{}
	placeholder      *string
	display_order    *int
	adddisplay_order *int
	enabled          *bool
	clearedFields    map[string]struct{}
	values           map[int64]struct{}
	removedvalues    map[int64]struct{}
	clearedvalues    bool
	done             bool
	oldValue         func(context.Context) (*UserAttributeDefinition, error)
	predicates       []predicate.UserAttributeDefinition
}

var _ ent.Mutation = (*UserAttributeDefinitionMutation)(nil)

// userattributedefinitionOption allows management of the mutation configuration using functional options.
type userattributedefinitionOption func(*UserAttributeDefinitionMutation)

// newUserAttributeDefinitionMutation creates new mutation for the UserAttributeDefinition entity.
func newUserAttributeDefinitionMutation(c config, op Op, opts ...userattributedefinitionOption) *UserAttributeDefinitionMutation {
	m := &UserAttributeDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAttributeDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAttributeDefinitionID sets the ID field of the mutation.
func withUserAttributeDefinitionID(id int64) userattributedefinitionOption {
	return func(m *UserAttributeDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAttributeDefinition
		)
		m.oldValue = func(ctx context.Context) (*UserAttributeDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAttributeDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAttributeDefinition sets the old UserAttributeDefinition of the mutation.
func withUserAttributeDefinition(node *UserAttributeDefinition) userattributedefinitionOption {
	return func(m *UserAttributeDefinitionMutation) {
		m.oldValue = func(context.Context) (*UserAttributeDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAttributeDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAttributeDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAttributeDefinitionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAttributeDefinitionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAttributeDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAttributeDefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAttributeDefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAttributeDefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserAttributeDefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserAttributeDefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserAttributeDefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserAttributeDefinitionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserAttributeDefinitionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserAttributeDefinitionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userattributedefinition.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserAttributeDefinitionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userattributedefinition.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserAttributeDefinitionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userattributedefinition.FieldDeletedAt)
}

// SetKey sets the "key" field.
func (m *UserAttributeDefinitionMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UserAttributeDefinitionMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UserAttributeDefinitionMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *UserAttributeDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserAttributeDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserAttributeDefinitionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UserAttributeDefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserAttributeDefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserAttributeDefinitionMutation) ResetDescription() {
	m.description = nil
}

// SetType sets the "type" field.
func (m *UserAttributeDefinitionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserAttributeDefinitionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserAttributeDefinitionMutation) ResetType() {
	m._type = nil
}

// SetOptions sets the "options" field.
func (m *UserAttributeDefinitionMutation) SetOptions(value []map[string]interface{}) {
	m.options = &value
	m.appendoptions = nil
}

// Options returns the value of the "options" field in the mutation.
func (m *UserAttributeDefinitionMutation) Options() (r []map[string]interface{}, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldOptions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// AppendOptions adds value to the "options" field.
func (m *UserAttributeDefinitionMutation) AppendOptions(value []map[string]interface{}) {
	m.appendoptions = append(m.appendoptions, value...)
}

// AppendedOptions returns the list of values that were appended to the "options" field in this mutation.
func (m *UserAttributeDefinitionMutation) AppendedOptions() ([]map[string]interface{}, bool) {
	if len(m.appendoptions) == 0 {
		return nil, false
	}
	return m.appendoptions, true
}

// ResetOptions resets all changes to the "options" field.
func (m *UserAttributeDefinitionMutation) ResetOptions() {
	m.options = nil
	m.appendoptions = nil
}

// SetRequired sets the "required" field.
func (m *UserAttributeDefinitionMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *UserAttributeDefinitionMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *UserAttributeDefinitionMutation) ResetRequired() {
	m.required = nil
}

// SetValidation sets the "validation" field.
func (m *UserAttributeDefinitionMutation) SetValidation(value map[string]interface{}) {
	m.validation = &value
}

// Validation returns the value of the "validation" field in the mutation.
func (m *UserAttributeDefinitionMutation) Validation() (r map[string]interface{}, exists bool) {
	v := m.validation
	if v == nil {
		return
	}
	return *v, true
}

// OldValidation returns the old "validation" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldValidation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidation: %w", err)
	}
	return oldValue.Validation, nil
}

// ResetValidation resets all changes to the "validation" field.
func (m *UserAttributeDefinitionMutation) ResetValidation() {
	m.validation = nil
}

// SetPlaceholder sets the "placeholder" field.
func (m *UserAttributeDefinitionMutation) SetPlaceholder(s string) {
	m.placeholder = &s
}

// Placeholder returns the value of the "placeholder" field in the mutation.
func (m *UserAttributeDefinitionMutation) Placeholder() (r string, exists bool) {
	v := m.placeholder
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceholder returns the old "placeholder" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldPlaceholder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceholder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceholder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceholder: %w", err)
	}
	return oldValue.Placeholder, nil
}

// ResetPlaceholder resets all changes to the "placeholder" field.
func (m *UserAttributeDefinitionMutation) ResetPlaceholder() {
	m.placeholder = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *UserAttributeDefinitionMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *UserAttributeDefinitionMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *UserAttributeDefinitionMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *UserAttributeDefinitionMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *UserAttributeDefinitionMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetEnabled sets the "enabled" field.
func (m *UserAttributeDefinitionMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *UserAttributeDefinitionMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *UserAttributeDefinitionMutation) ResetEnabled() {
	m.enabled = nil
}

// AddValueIDs adds the "values" edge to the UserAttributeValue entity by ids.
func (m *UserAttributeDefinitionMutation) AddValueIDs(ids ...int64) {
	if m.values == nil {
		m.values = make(map[int64]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the UserAttributeValue entity.
func (m *UserAttributeDefinitionMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the UserAttributeValue entity was cleared.
func (m *UserAttributeDefinitionMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the UserAttributeValue entity by IDs.
func (m *UserAttributeDefinitionMutation) RemoveValueIDs(ids ...int64) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the UserAttributeValue entity.
func (m *UserAttributeDefinitionMutation) RemovedValuesIDs() (ids []int64) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *UserAttributeDefinitionMutation) ValuesIDs() (ids []int64) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *UserAttributeDefinitionMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// Where appends a list predicates to the UserAttributeDefinitionMutation builder.
func (m *UserAttributeDefinitionMutation) Where(ps ...predicate.UserAttributeDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAttributeDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAttributeDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAttributeDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAttributeDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAttributeDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAttributeDefinition).
func (m *UserAttributeDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAttributeDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, userattributedefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userattributedefinition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userattributedefinition.FieldDeletedAt)
	}
	if m.key != nil {
		fields = append(fields, userattributedefinition.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, userattributedefinition.FieldName)
	}
	if m.description != nil {
		fields = append(fields, userattributedefinition.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, userattributedefinition.FieldType)
	}
	if m.options != nil {
		fields = append(fields, userattributedefinition.FieldOptions)
	}
	if m.required != nil {
		fields = append(fields, userattributedefinition.FieldRequired)
	}
	if m.validation != nil {
		fields = append(fields, userattributedefinition.FieldValidation)
	}
	if m.placeholder != nil {
		fields = append(fields, userattributedefinition.FieldPlaceholder)
	}
	if m.display_order != nil {
		fields = append(fields, userattributedefinition.FieldDisplayOrder)
	}
	if m.enabled != nil {
		fields = append(fields, userattributedefinition.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAttributeDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userattributedefinition.FieldCreatedAt:
		return m.CreatedAt()
	case userattributedefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	case userattributedefinition.FieldDeletedAt:
		return m.DeletedAt()
	case userattributedefinition.FieldKey:
		return m.Key()
	case userattributedefinition.FieldName:
		return m.Name()
	case userattributedefinition.FieldDescription:
		return m.Description()
	case userattributedefinition.FieldType:
		return m.GetType()
	case userattributedefinition.FieldOptions:
		return m.Options()
	case userattributedefinition.FieldRequired:
		return m.Required()
	case userattributedefinition.FieldValidation:
		return m.Validation()
	case userattributedefinition.FieldPlaceholder:
		return m.Placeholder()
	case userattributedefinition.FieldDisplayOrder:
		return m.DisplayOrder()
	case userattributedefinition.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAttributeDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userattributedefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userattributedefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userattributedefinition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userattributedefinition.FieldKey:
		return m.OldKey(ctx)
	case userattributedefinition.FieldName:
		return m.OldName(ctx)
	case userattributedefinition.FieldDescription:
		return m.OldDescription(ctx)
	case userattributedefinition.FieldType:
		return m.OldType(ctx)
	case userattributedefinition.FieldOptions:
		return m.OldOptions(ctx)
	case userattributedefinition.FieldRequired:
		return m.OldRequired(ctx)
	case userattributedefinition.FieldValidation:
		return m.OldValidation(ctx)
	case userattributedefinition.FieldPlaceholder:
		return m.OldPlaceholder(ctx)
	case userattributedefinition.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case userattributedefinition.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown UserAttributeDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAttributeDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userattributedefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userattributedefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userattributedefinition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userattributedefinition.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case userattributedefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case userattributedefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case userattributedefinition.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case userattributedefinition.FieldOptions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	case userattributedefinition.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case userattributedefinition.FieldValidation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidation(v)
		return nil
	case userattributedefinition.FieldPlaceholder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceholder(v)
		return nil
	case userattributedefinition.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case userattributedefinition.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown UserAttributeDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAttributeDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, userattributedefinition.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAttributeDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userattributedefinition.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAttributeDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userattributedefinition.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown UserAttributeDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAttributeDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userattributedefinition.FieldDeletedAt) {
		fields = append(fields, userattributedefinition.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAttributeDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAttributeDefinitionMutation) ClearField(name string) error {
	switch name {
	case userattributedefinition.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAttributeDefinitionMutation) ResetField(name string) error {
	switch name {
	case userattributedefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userattributedefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userattributedefinition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userattributedefinition.FieldKey:
		m.ResetKey()
		return nil
	case userattributedefinition.FieldName:
		m.ResetName()
		return nil
	case userattributedefinition.FieldDescription:
		m.ResetDescription()
		return nil
	case userattributedefinition.FieldType:
		m.ResetType()
		return nil
	case userattributedefinition.FieldOptions:
		m.ResetOptions()
		return nil
	case userattributedefinition.FieldRequired:
		m.ResetRequired()
		return nil
	case userattributedefinition.FieldValidation:
		m.ResetValidation()
		return nil
	case userattributedefinition.FieldPlaceholder:
		m.ResetPlaceholder()
		return nil
	case userattributedefinition.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case userattributedefinition.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAttributeDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.values != nil {
		edges = append(edges, userattributedefinition.EdgeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAttributeDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userattributedefinition.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAttributeDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvalues != nil {
		edges = append(edges, userattributedefinition.EdgeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAttributeDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userattributedefinition.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAttributeDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvalues {
		edges = append(edges, userattributedefinition.EdgeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAttributeDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case userattributedefinition.EdgeValues:
		return m.clearedvalues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAttributeDefinitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAttributeDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAttributeDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case userattributedefinition.EdgeValues:
		m.ResetValues()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeDefinition edge %s", name)
}

// UserAttributeValueMutation represents an operation that mutates the UserAttributeValue nodes in the graph.
type UserAttributeValueMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	value             *string
	clearedFields     map[string]struct{}
	user              *int64
	cleareduser       bool
	definition        *int64
	cleareddefinition bool
	done              bool
	oldValue          func(context.Context) (*UserAttributeValue, error)
	predicates        []predicate.UserAttributeValue
}

var _ ent.Mutation = (*UserAttributeValueMutation)(nil)

// userattributevalueOption allows management of the mutation configuration using functional options.
type userattributevalueOption func(*UserAttributeValueMutation)

// newUserAttributeValueMutation creates new mutation for the UserAttributeValue entity.
func newUserAttributeValueMutation(c config, op Op, opts ...userattributevalueOption) *UserAttributeValueMutation {
	m := &UserAttributeValueMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAttributeValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAttributeValueID sets the ID field of the mutation.
func withUserAttributeValueID(id int64) userattributevalueOption {
	return func(m *UserAttributeValueMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAttributeValue
		)
		m.oldValue = func(ctx context.Context) (*UserAttributeValue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAttributeValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAttributeValue sets the old UserAttributeValue of the mutation.
func withUserAttributeValue(node *UserAttributeValue) userattributevalueOption {
	return func(m *UserAttributeValueMutation) {
		m.oldValue = func(context.Context) (*UserAttributeValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAttributeValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAttributeValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAttributeValueMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAttributeValueMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAttributeValue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAttributeValueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAttributeValueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAttributeValueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserAttributeValueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserAttributeValueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserAttributeValueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserAttributeValueMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAttributeValueMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAttributeValueMutation) ResetUserID() {
	m.user = nil
}

// SetAttributeID sets the "attribute_id" field.
func (m *UserAttributeValueMutation) SetAttributeID(i int64) {
	m.definition = &i
}

// AttributeID returns the value of the "attribute_id" field in the mutation.
func (m *UserAttributeValueMutation) AttributeID() (r int64, exists bool) {
	v := m.definition
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributeID returns the old "attribute_id" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldAttributeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributeID: %w", err)
	}
	return oldValue.AttributeID, nil
}

// ResetAttributeID resets all changes to the "attribute_id" field.
func (m *UserAttributeValueMutation) ResetAttributeID() {
	m.definition = nil
}

// SetValue sets the "value" field.
func (m *UserAttributeValueMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *UserAttributeValueMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *UserAttributeValueMutation) ResetValue() {
	m.value = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAttributeValueMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userattributevalue.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAttributeValueMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAttributeValueMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAttributeValueMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetDefinitionID sets the "definition" edge to the UserAttributeDefinition entity by id.
func (m *UserAttributeValueMutation) SetDefinitionID(id int64) {
	m.definition = &id
}

// ClearDefinition clears the "definition" edge to the UserAttributeDefinition entity.
func (m *UserAttributeValueMutation) ClearDefinition() {
	m.cleareddefinition = true
	m.clearedFields[userattributevalue.FieldAttributeID] = struct{}{}
}

// DefinitionCleared reports if the "definition" edge to the UserAttributeDefinition entity was cleared.
func (m *UserAttributeValueMutation) DefinitionCleared() bool {
	return m.cleareddefinition
}

// DefinitionID returns the "definition" edge ID in the mutation.
func (m *UserAttributeValueMutation) DefinitionID() (id int64, exists bool) {
	if m.definition != nil {
		return *m.definition, true
	}
	return
}

// DefinitionIDs returns the "definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefinitionID instead. It exists only for internal usage by the builders.
func (m *UserAttributeValueMutation) DefinitionIDs() (ids []int64) {
	if id := m.definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefinition resets all changes to the "definition" edge.
func (m *UserAttributeValueMutation) ResetDefinition() {
	m.definition = nil
	m.cleareddefinition = false
}

// Where appends a list predicates to the UserAttributeValueMutation builder.
func (m *UserAttributeValueMutation) Where(ps ...predicate.UserAttributeValue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAttributeValueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAttributeValueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAttributeValue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAttributeValueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAttributeValueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAttributeValue).
func (m *UserAttributeValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAttributeValueMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, userattributevalue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userattributevalue.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userattributevalue.FieldUserID)
	}
	if m.definition != nil {
		fields = append(fields, userattributevalue.FieldAttributeID)
	}
	if m.value != nil {
		fields = append(fields, userattributevalue.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAttributeValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userattributevalue.FieldCreatedAt:
		return m.CreatedAt()
	case userattributevalue.FieldUpdatedAt:
		return m.UpdatedAt()
	case userattributevalue.FieldUserID:
		return m.UserID()
	case userattributevalue.FieldAttributeID:
		return m.AttributeID()
	case userattributevalue.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAttributeValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userattributevalue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userattributevalue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userattributevalue.FieldUserID:
		return m.OldUserID(ctx)
	case userattributevalue.FieldAttributeID:
		return m.OldAttributeID(ctx)
	case userattributevalue.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown UserAttributeValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAttributeValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userattributevalue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userattributevalue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userattributevalue.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userattributevalue.FieldAttributeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributeID(v)
		return nil
	case userattributevalue.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAttributeValueMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAttributeValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAttributeValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAttributeValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAttributeValueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAttributeValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAttributeValueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserAttributeValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAttributeValueMutation) ResetField(name string) error {
	switch name {
	case userattributevalue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userattributevalue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userattributevalue.FieldUserID:
		m.ResetUserID()
		return nil
	case userattributevalue.FieldAttributeID:
		m.ResetAttributeID()
		return nil
	case userattributevalue.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAttributeValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userattributevalue.EdgeUser)
	}
	if m.definition != nil {
		edges = append(edges, userattributevalue.EdgeDefinition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAttributeValueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userattributevalue.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userattributevalue.EdgeDefinition:
		if id := m.definition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAttributeValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAttributeValueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAttributeValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userattributevalue.EdgeUser)
	}
	if m.cleareddefinition {
		edges = append(edges, userattributevalue.EdgeDefinition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAttributeValueMutation) EdgeCleared(name string) bool {
	switch name {
	case userattributevalue.EdgeUser:
		return m.cleareduser
	case userattributevalue.EdgeDefinition:
		return m.cleareddefinition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAttributeValueMutation) ClearEdge(name string) error {
	switch name {
	case userattributevalue.EdgeUser:
		m.ClearUser()
		return nil
	case userattributevalue.EdgeDefinition:
		m.ClearDefinition()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAttributeValueMutation) ResetEdge(name string) error {
	switch name {
	case userattributevalue.EdgeUser:
		m.ResetUser()
		return nil
	case userattributevalue.EdgeDefinition:
		m.ResetDefinition()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue edge %s", name)
}

// UserSubscriptionMutation represents an operation that mutates the UserSubscription nodes in the graph.
type UserSubscriptionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	starts_at               *time.Time
	expires_at              *time.Time
	status                  *string
	daily_window_start      *time.Time
	weekly_window_start     *time.Time
	monthly_window_start    *time.Time
	daily_usage_usd         *float64
	adddaily_usage_usd      *float64
	weekly_usage_usd        *float64
	addweekly_usage_usd     *float64
	monthly_usage_usd       *float64
	addmonthly_usage_usd    *float64
	assigned_at             *time.Time
	notes                   *string
	clearedFields           map[string]struct{}
	user                    *int64
	cleareduser             bool
	group                   *int64
	clearedgroup            bool
	assigned_by_user        *int64
	clearedassigned_by_user bool
	usage_logs              map[int64]struct{}
	removedusage_logs       map[int64]struct{}
	clearedusage_logs       bool
	done                    bool
	oldValue                func(context.Context) (*UserSubscription, error)
	predicates              []predicate.UserSubscription
}

var _ ent.Mutation = (*UserSubscriptionMutation)(nil)

// usersubscriptionOption allows management of the mutation configuration using functional options.
type usersubscriptionOption func(*UserSubscriptionMutation)

// newUserSubscriptionMutation creates new mutation for the UserSubscription entity.
func newUserSubscriptionMutation(c config, op Op, opts ...usersubscriptionOption) *UserSubscriptionMutation {
	m := &UserSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSubscriptionID sets the ID field of the mutation.
func withUserSubscriptionID(id int64) usersubscriptionOption {
	return func(m *UserSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSubscription
		)
		m.oldValue = func(ctx context.Context) (*UserSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSubscription sets the old UserSubscription of the mutation.
func withUserSubscription(node *UserSubscription) usersubscriptionOption {
	return func(m *UserSubscriptionMutation) {
		m.oldValue = func(context.Context) (*UserSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSubscriptionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSubscriptionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserSubscriptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserSubscriptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserSubscriptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usersubscription.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserSubscriptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserSubscriptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usersubscription.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserSubscriptionMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSubscriptionMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSubscriptionMutation) ResetUserID() {
	m.user = nil
}

// SetGroupID sets the "group_id" field.
func (m *UserSubscriptionMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *UserSubscriptionMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *UserSubscriptionMutation) ResetGroupID() {
	m.group = nil
}

// SetStartsAt sets the "starts_at" field.
func (m *UserSubscriptionMutation) SetStartsAt(t time.Time) {
	m.starts_at = &t
}

// StartsAt returns the value of the "starts_at" field in the mutation.
func (m *UserSubscriptionMutation) StartsAt() (r time.Time, exists bool) {
	v := m.starts_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAt returns the old "starts_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldStartsAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAt: %w", err)
	}
	return oldValue.StartsAt, nil
}

// ResetStartsAt resets all changes to the "starts_at" field.
func (m *UserSubscriptionMutation) ResetStartsAt() {
	m.starts_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserSubscriptionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserSubscriptionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserSubscriptionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetStatus sets the "status" field.
func (m *UserSubscriptionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserSubscriptionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserSubscriptionMutation) ResetStatus() {
	m.status = nil
}

// SetDailyWindowStart sets the "daily_window_start" field.
func (m *UserSubscriptionMutation) SetDailyWindowStart(t time.Time) {
	m.daily_window_start = &t
}

// DailyWindowStart returns the value of the "daily_window_start" field in the mutation.
func (m *UserSubscriptionMutation) DailyWindowStart() (r time.Time, exists bool) {
	v := m.daily_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyWindowStart returns the old "daily_window_start" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldDailyWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyWindowStart: %w", err)
	}
	return oldValue.DailyWindowStart, nil
}

// ClearDailyWindowStart clears the value of the "daily_window_start" field.
func (m *UserSubscriptionMutation) ClearDailyWindowStart() {
	m.daily_window_start = nil
	m.clearedFields[usersubscription.FieldDailyWindowStart] = struct{}{}
}

// DailyWindowStartCleared returns if the "daily_window_start" field was cleared in this mutation.
func (m *UserSubscriptionMutation) DailyWindowStartCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldDailyWindowStart]
	return ok
}

// ResetDailyWindowStart resets all changes to the "daily_window_start" field.
func (m *UserSubscriptionMutation) ResetDailyWindowStart() {
	m.daily_window_start = nil
	delete(m.clearedFields, usersubscription.FieldDailyWindowStart)
}

// SetWeeklyWindowStart sets the "weekly_window_start" field.
func (m *UserSubscriptionMutation) SetWeeklyWindowStart(t time.Time) {
	m.weekly_window_start = &t
}

// WeeklyWindowStart returns the value of the "weekly_window_start" field in the mutation.
func (m *UserSubscriptionMutation) WeeklyWindowStart() (r time.Time, exists bool) {
	v := m.weekly_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWeeklyWindowStart returns the old "weekly_window_start" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldWeeklyWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeeklyWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeeklyWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeeklyWindowStart: %w", err)
	}
	return oldValue.WeeklyWindowStart, nil
}

// ClearWeeklyWindowStart clears the value of the "weekly_window_start" field.
func (m *UserSubscriptionMutation) ClearWeeklyWindowStart() {
	m.weekly_window_start = nil
	m.clearedFields[usersubscription.FieldWeeklyWindowStart] = struct{}{}
}

// WeeklyWindowStartCleared returns if the "weekly_window_start" field was cleared in this mutation.
func (m *UserSubscriptionMutation) WeeklyWindowStartCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldWeeklyWindowStart]
	return ok
}

// ResetWeeklyWindowStart resets all changes to the "weekly_window_start" field.
func (m *UserSubscriptionMutation) ResetWeeklyWindowStart() {
	m.weekly_window_start = nil
	delete(m.clearedFields, usersubscription.FieldWeeklyWindowStart)
}

// SetMonthlyWindowStart sets the "monthly_window_start" field.
func (m *UserSubscriptionMutation) SetMonthlyWindowStart(t time.Time) {
	m.monthly_window_start = &t
}

// MonthlyWindowStart returns the value of the "monthly_window_start" field in the mutation.
func (m *UserSubscriptionMutation) MonthlyWindowStart() (r time.Time, exists bool) {
	v := m.monthly_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyWindowStart returns the old "monthly_window_start" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldMonthlyWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyWindowStart: %w", err)
	}
	return oldValue.MonthlyWindowStart, nil
}

// ClearMonthlyWindowStart clears the value of the "monthly_window_start" field.
func (m *UserSubscriptionMutation) ClearMonthlyWindowStart() {
	m.monthly_window_start = nil
	m.clearedFields[usersubscription.FieldMonthlyWindowStart] = struct{}{}
}

// MonthlyWindowStartCleared returns if the "monthly_window_start" field was cleared in this mutation.
func (m *UserSubscriptionMutation) MonthlyWindowStartCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldMonthlyWindowStart]
	return ok
}

// ResetMonthlyWindowStart resets all changes to the "monthly_window_start" field.
func (m *UserSubscriptionMutation) ResetMonthlyWindowStart() {
	m.monthly_window_start = nil
	delete(m.clearedFields, usersubscription.FieldMonthlyWindowStart)
}

// SetDailyUsageUsd sets the "daily_usage_usd" field.
func (m *UserSubscriptionMutation) SetDailyUsageUsd(f float64) {
	m.daily_usage_usd = &f
	m.adddaily_usage_usd = nil
}

// DailyUsageUsd returns the value of the "daily_usage_usd" field in the mutation.
func (m *UserSubscriptionMutation) DailyUsageUsd() (r float64, exists bool) {
	v := m.daily_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyUsageUsd returns the old "daily_usage_usd" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldDailyUsageUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyUsageUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyUsageUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyUsageUsd: %w", err)
	}
	return oldValue.DailyUsageUsd, nil
}

// AddDailyUsageUsd adds f to the "daily_usage_usd" field.
func (m *UserSubscriptionMutation) AddDailyUsageUsd(f float64) {
	if m.adddaily_usage_usd != nil {
		*m.adddaily_usage_usd += f
	} else {
		m.adddaily_usage_usd = &f
	}
}

// AddedDailyUsageUsd returns the value that was added to the "daily_usage_usd" field in this mutation.
func (m *UserSubscriptionMutation) AddedDailyUsageUsd() (r float64, exists bool) {
	v := m.adddaily_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyUsageUsd resets all changes to the "daily_usage_usd" field.
func (m *UserSubscriptionMutation) ResetDailyUsageUsd() {
	m.daily_usage_usd = nil
	m.adddaily_usage_usd = nil
}

// SetWeeklyUsageUsd sets the "weekly_usage_usd" field.
func (m *UserSubscriptionMutation) SetWeeklyUsageUsd(f float64) {
	m.weekly_usage_usd = &f
	m.addweekly_usage_usd = nil
}

// WeeklyUsageUsd returns the value of the "weekly_usage_usd" field in the mutation.
func (m *UserSubscriptionMutation) WeeklyUsageUsd() (r float64, exists bool) {
	v := m.weekly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldWeeklyUsageUsd returns the old "weekly_usage_usd" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldWeeklyUsageUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeeklyUsageUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeeklyUsageUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeeklyUsageUsd: %w", err)
	}
	return oldValue.WeeklyUsageUsd, nil
}

// AddWeeklyUsageUsd adds f to the "weekly_usage_usd" field.
func (m *UserSubscriptionMutation) AddWeeklyUsageUsd(f float64) {
	if m.addweekly_usage_usd != nil {
		*m.addweekly_usage_usd += f
	} else {
		m.addweekly_usage_usd = &f
	}
}

// AddedWeeklyUsageUsd returns the value that was added to the "weekly_usage_usd" field in this mutation.
func (m *UserSubscriptionMutation) AddedWeeklyUsageUsd() (r float64, exists bool) {
	v := m.addweekly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeeklyUsageUsd resets all changes to the "weekly_usage_usd" field.
func (m *UserSubscriptionMutation) ResetWeeklyUsageUsd() {
	m.weekly_usage_usd = nil
	m.addweekly_usage_usd = nil
}

// SetMonthlyUsageUsd sets the "monthly_usage_usd" field.
func (m *UserSubscriptionMutation) SetMonthlyUsageUsd(f float64) {
	m.monthly_usage_usd = &f
	m.addmonthly_usage_usd = nil
}

// MonthlyUsageUsd returns the value of the "monthly_usage_usd" field in the mutation.
func (m *UserSubscriptionMutation) MonthlyUsageUsd() (r float64, exists bool) {
	v := m.monthly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyUsageUsd returns the old "monthly_usage_usd" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldMonthlyUsageUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyUsageUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyUsageUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyUsageUsd: %w", err)
	}
	return oldValue.MonthlyUsageUsd, nil
}

// AddMonthlyUsageUsd adds f to the "monthly_usage_usd" field.
func (m *UserSubscriptionMutation) AddMonthlyUsageUsd(f float64) {
	if m.addmonthly_usage_usd != nil {
		*m.addmonthly_usage_usd += f
	} else {
		m.addmonthly_usage_usd = &f
	}
}

// AddedMonthlyUsageUsd returns the value that was added to the "monthly_usage_usd" field in this mutation.
func (m *UserSubscriptionMutation) AddedMonthlyUsageUsd() (r float64, exists bool) {
	v := m.addmonthly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonthlyUsageUsd resets all changes to the "monthly_usage_usd" field.
func (m *UserSubscriptionMutation) ResetMonthlyUsageUsd() {
	m.monthly_usage_usd = nil
	m.addmonthly_usage_usd = nil
}

// SetAssignedBy sets the "assigned_by" field.
func (m *UserSubscriptionMutation) SetAssignedBy(i int64) {
	m.assigned_by_user = &i
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *UserSubscriptionMutation) AssignedBy() (r int64, exists bool) {
	v := m.assigned_by_user
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldAssignedBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *UserSubscriptionMutation) ClearAssignedBy() {
	m.assigned_by_user = nil
	m.clearedFields[usersubscription.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *UserSubscriptionMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *UserSubscriptionMutation) ResetAssignedBy() {
	m.assigned_by_user = nil
	delete(m.clearedFields, usersubscription.FieldAssignedBy)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *UserSubscriptionMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *UserSubscriptionMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *UserSubscriptionMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetNotes sets the "notes" field.
func (m *UserSubscriptionMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *UserSubscriptionMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *UserSubscriptionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[usersubscription.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *UserSubscriptionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *UserSubscriptionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, usersubscription.FieldNotes)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usersubscription.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSubscriptionMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UserSubscriptionMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[usersubscription.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UserSubscriptionMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserSubscriptionMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserSubscriptionMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// SetAssignedByUserID sets the "assigned_by_user" edge to the User entity by id.
func (m *UserSubscriptionMutation) SetAssignedByUserID(id int64) {
	m.assigned_by_user = &id
}

// ClearAssignedByUser clears the "assigned_by_user" edge to the User entity.
func (m *UserSubscriptionMutation) ClearAssignedByUser() {
	m.clearedassigned_by_user = true
	m.clearedFields[usersubscription.FieldAssignedBy] = struct{}{}
}

// AssignedByUserCleared reports if the "assigned_by_user" edge to the User entity was cleared.
func (m *UserSubscriptionMutation) AssignedByUserCleared() bool {
	return m.AssignedByCleared() || m.clearedassigned_by_user
}

// AssignedByUserID returns the "assigned_by_user" edge ID in the mutation.
func (m *UserSubscriptionMutation) AssignedByUserID() (id int64, exists bool) {
	if m.assigned_by_user != nil {
		return *m.assigned_by_user, true
	}
	return
}

// AssignedByUserIDs returns the "assigned_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignedByUserID instead. It exists only for internal usage by the builders.
func (m *UserSubscriptionMutation) AssignedByUserIDs() (ids []int64) {
	if id := m.assigned_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignedByUser resets all changes to the "assigned_by_user" edge.
func (m *UserSubscriptionMutation) ResetAssignedByUser() {
	m.assigned_by_user = nil
	m.clearedassigned_by_user = false
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *UserSubscriptionMutation) AddUsageLogIDs(ids ...int64) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *UserSubscriptionMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *UserSubscriptionMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *UserSubscriptionMutation) RemoveUsageLogIDs(ids ...int64) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *UserSubscriptionMutation) RemovedUsageLogsIDs() (ids []int64) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *UserSubscriptionMutation) UsageLogsIDs() (ids []int64) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *UserSubscriptionMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the UserSubscriptionMutation builder.
func (m *UserSubscriptionMutation) Where(ps ...predicate.UserSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSubscription).
func (m *UserSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, usersubscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersubscription.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usersubscription.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, usersubscription.FieldUserID)
	}
	if m.group != nil {
		fields = append(fields, usersubscription.FieldGroupID)
	}
	if m.starts_at != nil {
		fields = append(fields, usersubscription.FieldStartsAt)
	}
	if m.expires_at != nil {
		fields = append(fields, usersubscription.FieldExpiresAt)
	}
	if m.status != nil {
		fields = append(fields, usersubscription.FieldStatus)
	}
	if m.daily_window_start != nil {
		fields = append(fields, usersubscription.FieldDailyWindowStart)
	}
	if m.weekly_window_start != nil {
		fields = append(fields, usersubscription.FieldWeeklyWindowStart)
	}
	if m.monthly_window_start != nil {
		fields = append(fields, usersubscription.FieldMonthlyWindowStart)
	}
	if m.daily_usage_usd != nil {
		fields = append(fields, usersubscription.FieldDailyUsageUsd)
	}
	if m.weekly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldWeeklyUsageUsd)
	}
	if m.monthly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldMonthlyUsageUsd)
	}
	if m.assigned_by_user != nil {
		fields = append(fields, usersubscription.FieldAssignedBy)
	}
	if m.assigned_at != nil {
		fields = append(fields, usersubscription.FieldAssignedAt)
	}
	if m.notes != nil {
		fields = append(fields, usersubscription.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersubscription.FieldCreatedAt:
		return m.CreatedAt()
	case usersubscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersubscription.FieldDeletedAt:
		return m.DeletedAt()
	case usersubscription.FieldUserID:
		return m.UserID()
	case usersubscription.FieldGroupID:
		return m.GroupID()
	case usersubscription.FieldStartsAt:
		return m.StartsAt()
	case usersubscription.FieldExpiresAt:
		return m.ExpiresAt()
	case usersubscription.FieldStatus:
		return m.Status()
	case usersubscription.FieldDailyWindowStart:
		return m.DailyWindowStart()
	case usersubscription.FieldWeeklyWindowStart:
		return m.WeeklyWindowStart()
	case usersubscription.FieldMonthlyWindowStart:
		return m.MonthlyWindowStart()
	case usersubscription.FieldDailyUsageUsd:
		return m.DailyUsageUsd()
	case usersubscription.FieldWeeklyUsageUsd:
		return m.WeeklyUsageUsd()
	case usersubscription.FieldMonthlyUsageUsd:
		return m.MonthlyUsageUsd()
	case usersubscription.FieldAssignedBy:
		return m.AssignedBy()
	case usersubscription.FieldAssignedAt:
		return m.AssignedAt()
	case usersubscription.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersubscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersubscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersubscription.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usersubscription.FieldUserID:
		return m.OldUserID(ctx)
	case usersubscription.FieldGroupID:
		return m.OldGroupID(ctx)
	case usersubscription.FieldStartsAt:
		return m.OldStartsAt(ctx)
	case usersubscription.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case usersubscription.FieldStatus:
		return m.OldStatus(ctx)
	case usersubscription.FieldDailyWindowStart:
		return m.OldDailyWindowStart(ctx)
	case usersubscription.FieldWeeklyWindowStart:
		return m.OldWeeklyWindowStart(ctx)
	case usersubscription.FieldMonthlyWindowStart:
		return m.OldMonthlyWindowStart(ctx)
	case usersubscription.FieldDailyUsageUsd:
		return m.OldDailyUsageUsd(ctx)
	case usersubscription.FieldWeeklyUsageUsd:
		return m.OldWeeklyUsageUsd(ctx)
	case usersubscription.FieldMonthlyUsageUsd:
		return m.OldMonthlyUsageUsd(ctx)
	case usersubscription.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case usersubscription.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case usersubscription.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown UserSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersubscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersubscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersubscription.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usersubscription.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersubscription.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case usersubscription.FieldStartsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAt(v)
		return nil
	case usersubscription.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case usersubscription.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usersubscription.FieldDailyWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyWindowStart(v)
		return nil
	case usersubscription.FieldWeeklyWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeeklyWindowStart(v)
		return nil
	case usersubscription.FieldMonthlyWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyWindowStart(v)
		return nil
	case usersubscription.FieldDailyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyUsageUsd(v)
		return nil
	case usersubscription.FieldWeeklyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeeklyUsageUsd(v)
		return nil
	case usersubscription.FieldMonthlyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyUsageUsd(v)
		return nil
	case usersubscription.FieldAssignedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case usersubscription.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case usersubscription.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown UserSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.adddaily_usage_usd != nil {
		fields = append(fields, usersubscription.FieldDailyUsageUsd)
	}
	if m.addweekly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldWeeklyUsageUsd)
	}
	if m.addmonthly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldMonthlyUsageUsd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usersubscription.FieldDailyUsageUsd:
		return m.AddedDailyUsageUsd()
	case usersubscription.FieldWeeklyUsageUsd:
		return m.AddedWeeklyUsageUsd()
	case usersubscription.FieldMonthlyUsageUsd:
		return m.AddedMonthlyUsageUsd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usersubscription.FieldDailyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyUsageUsd(v)
		return nil
	case usersubscription.FieldWeeklyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeeklyUsageUsd(v)
		return nil
	case usersubscription.FieldMonthlyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonthlyUsageUsd(v)
		return nil
	}
	return fmt.Errorf("unknown UserSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersubscription.FieldDeletedAt) {
		fields = append(fields, usersubscription.FieldDeletedAt)
	}
	if m.FieldCleared(usersubscription.FieldDailyWindowStart) {
		fields = append(fields, usersubscription.FieldDailyWindowStart)
	}
	if m.FieldCleared(usersubscription.FieldWeeklyWindowStart) {
		fields = append(fields, usersubscription.FieldWeeklyWindowStart)
	}
	if m.FieldCleared(usersubscription.FieldMonthlyWindowStart) {
		fields = append(fields, usersubscription.FieldMonthlyWindowStart)
	}
	if m.FieldCleared(usersubscription.FieldAssignedBy) {
		fields = append(fields, usersubscription.FieldAssignedBy)
	}
	if m.FieldCleared(usersubscription.FieldNotes) {
		fields = append(fields, usersubscription.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSubscriptionMutation) ClearField(name string) error {
	switch name {
	case usersubscription.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case usersubscription.FieldDailyWindowStart:
		m.ClearDailyWindowStart()
		return nil
	case usersubscription.FieldWeeklyWindowStart:
		m.ClearWeeklyWindowStart()
		return nil
	case usersubscription.FieldMonthlyWindowStart:
		m.ClearMonthlyWindowStart()
		return nil
	case usersubscription.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	case usersubscription.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSubscriptionMutation) ResetField(name string) error {
	switch name {
	case usersubscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersubscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersubscription.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usersubscription.FieldUserID:
		m.ResetUserID()
		return nil
	case usersubscription.FieldGroupID:
		m.ResetGroupID()
		return nil
	case usersubscription.FieldStartsAt:
		m.ResetStartsAt()
		return nil
	case usersubscription.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case usersubscription.FieldStatus:
		m.ResetStatus()
		return nil
	case usersubscription.FieldDailyWindowStart:
		m.ResetDailyWindowStart()
		return nil
	case usersubscription.FieldWeeklyWindowStart:
		m.ResetWeeklyWindowStart()
		return nil
	case usersubscription.FieldMonthlyWindowStart:
		m.ResetMonthlyWindowStart()
		return nil
	case usersubscription.FieldDailyUsageUsd:
		m.ResetDailyUsageUsd()
		return nil
	case usersubscription.FieldWeeklyUsageUsd:
		m.ResetWeeklyUsageUsd()
		return nil
	case usersubscription.FieldMonthlyUsageUsd:
		m.ResetMonthlyUsageUsd()
		return nil
	case usersubscription.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case usersubscription.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case usersubscription.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, usersubscription.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, usersubscription.EdgeGroup)
	}
	if m.assigned_by_user != nil {
		edges = append(edges, usersubscription.EdgeAssignedByUser)
	}
	if m.usage_logs != nil {
		edges = append(edges, usersubscription.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usersubscription.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case usersubscription.EdgeAssignedByUser:
		if id := m.assigned_by_user; id != nil {
			return []ent.Value{*id}
		}
	case usersubscription.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedusage_logs != nil {
		edges = append(edges, usersubscription.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usersubscription.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, usersubscription.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, usersubscription.EdgeGroup)
	}
	if m.clearedassigned_by_user {
		edges = append(edges, usersubscription.EdgeAssignedByUser)
	}
	if m.clearedusage_logs {
		edges = append(edges, usersubscription.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersubscription.EdgeUser:
		return m.cleareduser
	case usersubscription.EdgeGroup:
		return m.clearedgroup
	case usersubscription.EdgeAssignedByUser:
		return m.clearedassigned_by_user
	case usersubscription.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case usersubscription.EdgeUser:
		m.ClearUser()
		return nil
	case usersubscription.EdgeGroup:
		m.ClearGroup()
		return nil
	case usersubscription.EdgeAssignedByUser:
		m.ClearAssignedByUser()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case usersubscription.EdgeUser:
		m.ResetUser()
		return nil
	case usersubscription.EdgeGroup:
		m.ResetGroup()
		return nil
	case usersubscription.EdgeAssignedByUser:
		m.ResetAssignedByUser()
		return nil
	case usersubscription.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription edge %s", name)
}
